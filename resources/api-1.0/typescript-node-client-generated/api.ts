/**
 * LogicGate API
 * Explore the LogicGate API - all the end points are listed below.
 *
 * OpenAPI spec version: 1
 * Contact: devs@logicgate.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http from 'http';
import Promise = require('bluebird');
import { ClientResponse } from 'http';
import { Options } from 'request'
import * as request from 'request';

let defaultBasePath = 'https://agilegrcsolutions.logicgate.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
    "string",
    "boolean",
    "double",
    "integer",
    "long",
    "float",
    "number",
    "any"
];


/**
* A super-class that is used to manage the relationship type between two connected workflows.
*/
export class WorkflowMap {
    'active'?: boolean;
    'childId'?: string;
    'created'?: Date;
    'id'?: string;
    'labels'?: Array<string>;
    'parentId'?: string;
    'parentResult'?: WorkflowResult;
    /**
    * Parent workflow.
    */
    'parentWorkflow'?: Workflow;
    'updated'?: Date;
    /**
    * Child workflow to be connected.
    */
    'workflow'?: Workflow;
    'workflowMapType'?: string;

    static discriminator: string | undefined = "workflowMapType";

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "childId",
            "baseName": "childId",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "string"
        },
        {
            "name": "parentResult",
            "baseName": "parentResult",
            "type": "WorkflowResult"
        },
        {
            "name": "parentWorkflow",
            "baseName": "parentWorkflow",
            "type": "Workflow"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowMapType",
            "baseName": "workflowMapType",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return WorkflowMap.attributeTypeMap;
    }
}

export class ManyToMany extends WorkflowMap {
    'active'?: boolean;
    'childId'?: string;
    'created'?: Date;
    'id'?: string;
    'labels'?: Array<string>;
    'parentId'?: string;
    'parentResult'?: WorkflowResult;
    /**
    * Parent workflow.
    */
    'parentWorkflow'?: Workflow;
    'updated'?: Date;
    /**
    * Child workflow to be connected.
    */
    'workflow'?: Workflow;
    'workflowMapType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "childId",
            "baseName": "childId",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "string"
        },
        {
            "name": "parentResult",
            "baseName": "parentResult",
            "type": "WorkflowResult"
        },
        {
            "name": "parentWorkflow",
            "baseName": "parentWorkflow",
            "type": "Workflow"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowMapType",
            "baseName": "workflowMapType",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ManyToMany.attributeTypeMap);
    }
}

export class ImportRequest {
    'active'?: boolean;
    'created'?: Date;
    'id'?: string;
    'importType'?: string;
    'labels'?: Array<string>;
    'updated'?: Date;

    static discriminator: string | undefined = "importType";

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "importType",
            "baseName": "importType",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }];

    static getAttributeTypeMap() {
        return ImportRequest.attributeTypeMap;
    }
}

/**
* An entity used to group a collection of layout fields related to record data
*/
export class Layout {
    'active'?: boolean;
    'created'?: Date;
    'defaultLayout'?: boolean;
    'id'?: string;
    'labels'?: Array<string>;
    'layoutFields'?: Array<LayoutField>;
    'title'?: string;
    'updated'?: Date;
    'workflow'?: Workflow;
    'workflowId'?: string;

    static discriminator: string | undefined = "layoutType";

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "defaultLayout",
            "baseName": "defaultLayout",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "layoutFields",
            "baseName": "layoutFields",
            "type": "Array<LayoutField>"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return Layout.attributeTypeMap;
    }
}


/**
* Entity used to manage record's field data.
*/
export class CurrentValue {
    'active'?: boolean;
    'archived'?: boolean;
    'created'?: Date;
    '_default'?: boolean;
    'discriminator'?: string;
    'empty'?: boolean;
    'field'?: Field;
    'fieldId'?: string;
    'hasValue'?: Field;
    'id'?: string;
    'isDefault'?: boolean;
    'labels'?: Array<string>;
    'numericValue'?: number;
    'priority'?: number;
    'textValue'?: string;
    'updated'?: Date;
    'valueType'?: string;

    static discriminator: string | undefined = "discriminator";

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "discriminator",
            "baseName": "discriminator",
            "type": "string"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        },
        {
            "name": "hasValue",
            "baseName": "hasValue",
            "type": "Field"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isDefault",
            "baseName": "isDefault",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "numericValue",
            "baseName": "numericValue",
            "type": "number"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "textValue",
            "baseName": "textValue",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return CurrentValue.attributeTypeMap;
    }
}

/**
* An entity to store details about a specific step within a workflow
*/
export class Step {
    'active'?: boolean;
    /**
    * Allow entitlements to the node.
    */
    'allowEntitlements'?: boolean;
    'chain'?: boolean;
    'contains'?: Workflow;
    'created'?: Date;
    'end'?: boolean;
    'id'?: string;
    /**
    * Allows a node to become a public node.
    */
    'isPublic'?: boolean;
    'labels'?: Array<string>;
    /**
    * Node name.
    */
    'name'?: string;
    'origin'?: boolean;
    /**
    * Determines the node's place in the workflow.
    */
    'priority'?: number;
    '_public'?: boolean;
    /**
    * Object containing all SLA information.
    */
    'sla'?: ServiceLevelAgreement;
    /**
    * Node type.
    */
    'stepType'?: string;
    'updated'?: Date;
    /**
    * Workflow that the node belongs to.
    */
    'workflow'?: Workflow;
    'workflowId'?: string;
    /**
    * Vertical position of the node on the process screen.
    */
    'xpos'?: number;
    /**
    * Horizontal position of the node on the process screen.
    */
    'ypos'?: number;

    static discriminator: string | undefined = "stepType";

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "allowEntitlements",
            "baseName": "allowEntitlements",
            "type": "boolean"
        },
        {
            "name": "chain",
            "baseName": "chain",
            "type": "boolean"
        },
        {
            "name": "contains",
            "baseName": "contains",
            "type": "Workflow"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "end",
            "baseName": "end",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isPublic",
            "baseName": "isPublic",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "origin",
            "baseName": "origin",
            "type": "boolean"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "_public",
            "baseName": "public",
            "type": "boolean"
        },
        {
            "name": "sla",
            "baseName": "sla",
            "type": "ServiceLevelAgreement"
        },
        {
            "name": "stepType",
            "baseName": "stepType",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        },
        {
            "name": "xpos",
            "baseName": "xpos",
            "type": "number"
        },
        {
            "name": "ypos",
            "baseName": "ypos",
            "type": "number"
        }];

    static getAttributeTypeMap() {
        return Step.attributeTypeMap;
    }
}

/**
* An entity used to manage input fields used to capture record data for different workflows.
*/
export class Field {
    'active'?: boolean;
    'convertibleTo'?: Array<string>;
    'created'?: Date;
    /**
    * Relationship to current values that are associated to the field.
    */
    'currentValues'?: Array<CurrentValue>;
    'discrete'?: boolean;
    'fieldType': Field.FieldTypeEnum;
    'global'?: boolean;
    'id'?: string;
    /**
    * The label will appear as the label for the field when it appears on forms for user's to complete.
    */
    'label'?: string;
    'labels'?: Array<string>;
    /**
    * The name of the field.
    */
    'name'?: string;
    'operators'?: Array<Field.OperatorsEnum>;
    /**
    * A text value that will populate any tooltip information.
    */
    'tooltip'?: string;
    'updated'?: Date;
    'valueType'?: string;
    /**
    * Workflow object that is associated to the field.
    */
    'workflow'?: Workflow;
    'workflowId'?: string;

    static discriminator: string | undefined = "fieldType";

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "convertibleTo",
            "baseName": "convertibleTo",
            "type": "Array<string>"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "currentValues",
            "baseName": "currentValues",
            "type": "Array<CurrentValue>"
        },
        {
            "name": "discrete",
            "baseName": "discrete",
            "type": "boolean"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "Field.FieldTypeEnum"
        },
        {
            "name": "global",
            "baseName": "global",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "operators",
            "baseName": "operators",
            "type": "Array<Field.OperatorsEnum>"
        },
        {
            "name": "tooltip",
            "baseName": "tooltip",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return Field.attributeTypeMap;
    }
}

/**
* Entity for storing all information pertaining to a user.
*/
export class User extends Field {
    'active'?: boolean;
    'archived'?: boolean;
    'assignments'?: Array<Record>;
    'company'?: string;
    'created'?: Date;
    '_default'?: boolean;
    'disabled'?: boolean;
    'discriminator'?: string;
    'email'?: string;
    'empty'?: boolean;
    'field'?: Field;
    'fieldId'?: string;
    'first'?: string;
    'hasValue'?: Field;
    'id'?: string;
    'imageUrl'?: string;
    'intercomHash'?: string;
    'isDefault'?: boolean;
    'labels'?: Array<string>;
    'languageTag'?: string;
    'last'?: string;
    'lastLogin'?: AccessAudit;
    'locked'?: boolean;
    'loginAttempts'?: number;
    'name'?: string;
    'numericValue'?: number;
    'password'?: string;
    'priority'?: number;
    'records'?: Array<Record>;
    'resetPasswordToken'?: string;
    'roles'?: Array<Role>;
    'sendEmail'?: boolean;
    'status'?: string;
    'superUser'?: boolean;
    'textValue'?: string;
    'tier'?: User.TierEnum;
    'timeZone'?: string;
    'updated'?: Date;
    'valueType'?: string;

    static discriminator: string | undefined = "status";

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "assignments",
            "baseName": "assignments",
            "type": "Array<Record>"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "disabled",
            "baseName": "disabled",
            "type": "boolean"
        },
        {
            "name": "discriminator",
            "baseName": "discriminator",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "string"
        },
        {
            "name": "hasValue",
            "baseName": "hasValue",
            "type": "Field"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "intercomHash",
            "baseName": "intercomHash",
            "type": "string"
        },
        {
            "name": "isDefault",
            "baseName": "isDefault",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "languageTag",
            "baseName": "languageTag",
            "type": "string"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "string"
        },
        {
            "name": "lastLogin",
            "baseName": "lastLogin",
            "type": "AccessAudit"
        },
        {
            "name": "locked",
            "baseName": "locked",
            "type": "boolean"
        },
        {
            "name": "loginAttempts",
            "baseName": "loginAttempts",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "numericValue",
            "baseName": "numericValue",
            "type": "number"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "records",
            "baseName": "records",
            "type": "Array<Record>"
        },
        {
            "name": "resetPasswordToken",
            "baseName": "resetPasswordToken",
            "type": "string"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<Role>"
        },
        {
            "name": "sendEmail",
            "baseName": "sendEmail",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "superUser",
            "baseName": "superUser",
            "type": "boolean"
        },
        {
            "name": "textValue",
            "baseName": "textValue",
            "type": "string"
        },
        {
            "name": "tier",
            "baseName": "tier",
            "type": "User.TierEnum"
        },
        {
            "name": "timeZone",
            "baseName": "timeZone",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(User.attributeTypeMap);
    }
}

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: { [index: string]: any } = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* Entity used to track authentication attempts.
*/
export class AccessAudit {
    'active'?: boolean;
    'created'?: Date;
    'id'?: string;
    'labels'?: Array<string>;
    'remoteAddress'?: string;
    'updated'?: Date;

    static discriminator: string | undefined = "accessType";

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "remoteAddress",
            "baseName": "remoteAddress",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }];

    static getAttributeTypeMap() {
        return AccessAudit.attributeTypeMap;
    }
}

export class Active extends User {
    'active'?: boolean;
    'archived'?: boolean;
    'assignments'?: Array<Record>;
    'company'?: string;
    'created'?: Date;
    '_default'?: boolean;
    'disabled'?: boolean;
    'discriminator'?: string;
    'email'?: string;
    'empty'?: boolean;
    'field'?: Field;
    'fieldId'?: string;
    'first'?: string;
    'hasValue'?: Field;
    'id'?: string;
    'imageUrl'?: string;
    'intercomHash'?: string;
    'isDefault'?: boolean;
    'labels'?: Array<string>;
    'languageTag'?: string;
    'last'?: string;
    'lastLogin'?: AccessAudit;
    'locked'?: boolean;
    'loginAttempts'?: number;
    'name'?: string;
    'numericValue'?: number;
    'password'?: string;
    'priority'?: number;
    'records'?: Array<Record>;
    'resetPasswordToken'?: string;
    'roles'?: Array<Role>;
    'sendEmail'?: boolean;
    'status'?: string;
    'superUser'?: boolean;
    'textValue'?: string;
    'tier'?: Active.TierEnum;
    'timeZone'?: string;
    'updated'?: Date;
    'valueType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "assignments",
            "baseName": "assignments",
            "type": "Array<Record>"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "disabled",
            "baseName": "disabled",
            "type": "boolean"
        },
        {
            "name": "discriminator",
            "baseName": "discriminator",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "string"
        },
        {
            "name": "hasValue",
            "baseName": "hasValue",
            "type": "Field"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "intercomHash",
            "baseName": "intercomHash",
            "type": "string"
        },
        {
            "name": "isDefault",
            "baseName": "isDefault",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "languageTag",
            "baseName": "languageTag",
            "type": "string"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "string"
        },
        {
            "name": "lastLogin",
            "baseName": "lastLogin",
            "type": "AccessAudit"
        },
        {
            "name": "locked",
            "baseName": "locked",
            "type": "boolean"
        },
        {
            "name": "loginAttempts",
            "baseName": "loginAttempts",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "numericValue",
            "baseName": "numericValue",
            "type": "number"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "records",
            "baseName": "records",
            "type": "Array<Record>"
        },
        {
            "name": "resetPasswordToken",
            "baseName": "resetPasswordToken",
            "type": "string"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<Role>"
        },
        {
            "name": "sendEmail",
            "baseName": "sendEmail",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "superUser",
            "baseName": "superUser",
            "type": "boolean"
        },
        {
            "name": "textValue",
            "baseName": "textValue",
            "type": "string"
        },
        {
            "name": "tier",
            "baseName": "tier",
            "type": "Active.TierEnum"
        },
        {
            "name": "timeZone",
            "baseName": "timeZone",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Active.attributeTypeMap);
    }
}

export namespace Active {
    export enum TierEnum {
        PRIMARY = <any>'PRIMARY',
        SECONDARY = <any>'SECONDARY',
        LIMITED = <any>'LIMITED'
    }
}
export class Attachment extends Field {
    'active'?: boolean;
    'convertibleTo'?: Array<string>;
    'created'?: Date;
    /**
    * Relationship to current values that are associated to the field.
    */
    'currentValues'?: Array<CurrentValue>;
    'discrete'?: boolean;
    'enableVersions'?: boolean;
    'fieldType': Attachment.FieldTypeEnum;
    'global'?: boolean;
    'id'?: string;
    /**
    * The label will appear as the label for the field when it appears on forms for user's to complete.
    */
    'label'?: string;
    'labels'?: Array<string>;
    /**
    * The name of the field.
    */
    'name'?: string;
    'operators'?: Array<Attachment.OperatorsEnum>;
    /**
    * A text value that will populate any tooltip information.
    */
    'tooltip'?: string;
    'updated'?: Date;
    'valueType'?: string;
    /**
    * Workflow object that is associated to the field.
    */
    'workflow'?: Workflow;
    'workflowId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "convertibleTo",
            "baseName": "convertibleTo",
            "type": "Array<string>"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "currentValues",
            "baseName": "currentValues",
            "type": "Array<CurrentValue>"
        },
        {
            "name": "discrete",
            "baseName": "discrete",
            "type": "boolean"
        },
        {
            "name": "enableVersions",
            "baseName": "enableVersions",
            "type": "boolean"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "Attachment.FieldTypeEnum"
        },
        {
            "name": "global",
            "baseName": "global",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "operators",
            "baseName": "operators",
            "type": "Array<Attachment.OperatorsEnum>"
        },
        {
            "name": "tooltip",
            "baseName": "tooltip",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Attachment.attributeTypeMap);
    }
}

export namespace Attachment {
    export enum FieldTypeEnum {
        TEXT = <any>'TEXT',
        TEXTAREA = <any>'TEXT_AREA',
        DATEPICKER = <any>'DATE_PICKER',
        NUMBER = <any>'NUMBER',
        ESIGNATURE = <any>'E_SIGNATURE',
        CHECKBOX = <any>'CHECKBOX',
        MULTISELECT = <any>'MULTI_SELECT',
        RADIO = <any>'RADIO',
        SELECT = <any>'SELECT',
        USER = <any>'USER',
        ATTACHMENT = <any>'ATTACHMENT',
        CALCULATION = <any>'CALCULATION',
        DUEDATE = <any>'DUE_DATE'
    }
    export enum OperatorsEnum {
        EQUALS = <any>'EQUALS',
        NOTEQUALS = <any>'NOT_EQUALS',
        GREATERTHAN = <any>'GREATER_THAN',
        GREATERTHANEQUALS = <any>'GREATER_THAN_EQUALS',
        LESSTHAN = <any>'LESS_THAN',
        LESSTHANEQUALS = <any>'LESS_THAN_EQUALS',
        CONTAINS = <any>'CONTAINS',
        DOESNOTCONTAIN = <any>'DOES_NOT_CONTAIN',
        NULL = <any>'NULL',
        NOTNULL = <any>'NOT_NULL',
        MATCHES = <any>'MATCHES',
        DATERANGE = <any>'DATE_RANGE'
    }
}
export class Calculation extends Field {
    'active'?: boolean;
    'convertibleTo'?: Array<string>;
    'created'?: Date;
    /**
    * Relationship to current values that are associated to the field.
    */
    'currentValues'?: Array<CurrentValue>;
    'discrete'?: boolean;
    'expression'?: string;
    /**
    * Fields used to evaluate the expression of the calculation
    */
    'fieldInputs'?: Array<FieldInput>;
    'fieldType': Calculation.FieldTypeEnum;
    'global'?: boolean;
    'id'?: string;
    /**
    * The label will appear as the label for the field when it appears on forms for user's to complete.
    */
    'label'?: string;
    'labels'?: Array<string>;
    'labelsEnabled'?: boolean;
    'logicalHandling'?: Calculation.LogicalHandlingEnum;
    /**
    * The name of the field.
    */
    'name'?: string;
    'nullStrategy'?: Calculation.NullStrategyEnum;
    'operators'?: Array<Calculation.OperatorsEnum>;
    /**
    * A text value that will populate any tooltip information.
    */
    'tooltip'?: string;
    'updated'?: Date;
    'valueType'?: string;
    /**
    * Workflow object that is associated to the field.
    */
    'workflow'?: Workflow;
    'workflowId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "convertibleTo",
            "baseName": "convertibleTo",
            "type": "Array<string>"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "currentValues",
            "baseName": "currentValues",
            "type": "Array<CurrentValue>"
        },
        {
            "name": "discrete",
            "baseName": "discrete",
            "type": "boolean"
        },
        {
            "name": "expression",
            "baseName": "expression",
            "type": "string"
        },
        {
            "name": "fieldInputs",
            "baseName": "fieldInputs",
            "type": "Array<FieldInput>"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "Calculation.FieldTypeEnum"
        },
        {
            "name": "global",
            "baseName": "global",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "labelsEnabled",
            "baseName": "labelsEnabled",
            "type": "boolean"
        },
        {
            "name": "logicalHandling",
            "baseName": "logicalHandling",
            "type": "Calculation.LogicalHandlingEnum"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "nullStrategy",
            "baseName": "nullStrategy",
            "type": "Calculation.NullStrategyEnum"
        },
        {
            "name": "operators",
            "baseName": "operators",
            "type": "Array<Calculation.OperatorsEnum>"
        },
        {
            "name": "tooltip",
            "baseName": "tooltip",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Calculation.attributeTypeMap);
    }
}

export namespace Calculation {
    export enum FieldTypeEnum {
        TEXT = <any>'TEXT',
        TEXTAREA = <any>'TEXT_AREA',
        DATEPICKER = <any>'DATE_PICKER',
        NUMBER = <any>'NUMBER',
        ESIGNATURE = <any>'E_SIGNATURE',
        CHECKBOX = <any>'CHECKBOX',
        MULTISELECT = <any>'MULTI_SELECT',
        RADIO = <any>'RADIO',
        SELECT = <any>'SELECT',
        USER = <any>'USER',
        ATTACHMENT = <any>'ATTACHMENT',
        CALCULATION = <any>'CALCULATION',
        DUEDATE = <any>'DUE_DATE'
    }
    export enum LogicalHandlingEnum {
        EQUALS = <any>'EQUALS',
        NOTEQUALS = <any>'NOT_EQUALS',
        GREATERTHAN = <any>'GREATER_THAN',
        GREATERTHANEQUALS = <any>'GREATER_THAN_EQUALS',
        LESSTHAN = <any>'LESS_THAN',
        LESSTHANEQUALS = <any>'LESS_THAN_EQUALS',
        CONTAINS = <any>'CONTAINS',
        DOESNOTCONTAIN = <any>'DOES_NOT_CONTAIN',
        NULL = <any>'NULL',
        NOTNULL = <any>'NOT_NULL',
        MATCHES = <any>'MATCHES',
        DATERANGE = <any>'DATE_RANGE'
    }
    export enum NullStrategyEnum {
        NULL = <any>'NULL',
        ZERO = <any>'ZERO',
        ONE = <any>'ONE'
    }
    export enum OperatorsEnum {
        EQUALS = <any>'EQUALS',
        NOTEQUALS = <any>'NOT_EQUALS',
        GREATERTHAN = <any>'GREATER_THAN',
        GREATERTHANEQUALS = <any>'GREATER_THAN_EQUALS',
        LESSTHAN = <any>'LESS_THAN',
        LESSTHANEQUALS = <any>'LESS_THAN_EQUALS',
        CONTAINS = <any>'CONTAINS',
        DOESNOTCONTAIN = <any>'DOES_NOT_CONTAIN',
        NULL = <any>'NULL',
        NOTNULL = <any>'NOT_NULL',
        MATCHES = <any>'MATCHES',
        DATERANGE = <any>'DATE_RANGE'
    }
}
export class Chain extends Step {
    'active'?: boolean;
    /**
    * Allow entitlements to the node.
    */
    'allowEntitlements'?: boolean;
    'chain'?: boolean;
    'contains'?: Workflow;
    'created'?: Date;
    'end'?: boolean;
    'id'?: string;
    /**
    * Allows a node to become a public node.
    */
    'isPublic'?: boolean;
    'labels'?: Array<string>;
    /**
    * Node name.
    */
    'name'?: string;
    'origin'?: boolean;
    /**
    * Determines the node's place in the workflow.
    */
    'priority'?: number;
    '_public'?: boolean;
    /**
    * Object containing all SLA information.
    */
    'sla'?: ServiceLevelAgreement;
    /**
    * Node type.
    */
    'stepType'?: string;
    'updated'?: Date;
    /**
    * Workflow that the node belongs to.
    */
    'workflow'?: Workflow;
    'workflowId'?: string;
    /**
    * Vertical position of the node on the process screen.
    */
    'xpos'?: number;
    /**
    * Horizontal position of the node on the process screen.
    */
    'ypos'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "allowEntitlements",
            "baseName": "allowEntitlements",
            "type": "boolean"
        },
        {
            "name": "chain",
            "baseName": "chain",
            "type": "boolean"
        },
        {
            "name": "contains",
            "baseName": "contains",
            "type": "Workflow"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "end",
            "baseName": "end",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isPublic",
            "baseName": "isPublic",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "origin",
            "baseName": "origin",
            "type": "boolean"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "_public",
            "baseName": "public",
            "type": "boolean"
        },
        {
            "name": "sla",
            "baseName": "sla",
            "type": "ServiceLevelAgreement"
        },
        {
            "name": "stepType",
            "baseName": "stepType",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        },
        {
            "name": "xpos",
            "baseName": "xpos",
            "type": "number"
        },
        {
            "name": "ypos",
            "baseName": "ypos",
            "type": "number"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Chain.attributeTypeMap);
    }
}

export class Checkbox extends Field {
    'active'?: boolean;
    'convertibleTo'?: Array<string>;
    'created'?: Date;
    /**
    * Relationship to current values that are associated to the field.
    */
    'currentValues'?: Array<CurrentValue>;
    'discrete'?: boolean;
    'fieldType': Checkbox.FieldTypeEnum;
    'global'?: boolean;
    'id'?: string;
    /**
    * The label will appear as the label for the field when it appears on forms for user's to complete.
    */
    'label'?: string;
    'labels'?: Array<string>;
    /**
    * The name of the field.
    */
    'name'?: string;
    'operators'?: Array<Checkbox.OperatorsEnum>;
    /**
    * A text value that will populate any tooltip information.
    */
    'tooltip'?: string;
    'updated'?: Date;
    'valueType'?: string;
    /**
    * Workflow object that is associated to the field.
    */
    'workflow'?: Workflow;
    'workflowId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "convertibleTo",
            "baseName": "convertibleTo",
            "type": "Array<string>"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "currentValues",
            "baseName": "currentValues",
            "type": "Array<CurrentValue>"
        },
        {
            "name": "discrete",
            "baseName": "discrete",
            "type": "boolean"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "Checkbox.FieldTypeEnum"
        },
        {
            "name": "global",
            "baseName": "global",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "operators",
            "baseName": "operators",
            "type": "Array<Checkbox.OperatorsEnum>"
        },
        {
            "name": "tooltip",
            "baseName": "tooltip",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Checkbox.attributeTypeMap);
    }
}

export namespace Checkbox {
    export enum FieldTypeEnum {
        TEXT = <any>'TEXT',
        TEXTAREA = <any>'TEXT_AREA',
        DATEPICKER = <any>'DATE_PICKER',
        NUMBER = <any>'NUMBER',
        ESIGNATURE = <any>'E_SIGNATURE',
        CHECKBOX = <any>'CHECKBOX',
        MULTISELECT = <any>'MULTI_SELECT',
        RADIO = <any>'RADIO',
        SELECT = <any>'SELECT',
        USER = <any>'USER',
        ATTACHMENT = <any>'ATTACHMENT',
        CALCULATION = <any>'CALCULATION',
        DUEDATE = <any>'DUE_DATE'
    }
    export enum OperatorsEnum {
        EQUALS = <any>'EQUALS',
        NOTEQUALS = <any>'NOT_EQUALS',
        GREATERTHAN = <any>'GREATER_THAN',
        GREATERTHANEQUALS = <any>'GREATER_THAN_EQUALS',
        LESSTHAN = <any>'LESS_THAN',
        LESSTHANEQUALS = <any>'LESS_THAN_EQUALS',
        CONTAINS = <any>'CONTAINS',
        DOESNOTCONTAIN = <any>'DOES_NOT_CONTAIN',
        NULL = <any>'NULL',
        NOTNULL = <any>'NOT_NULL',
        MATCHES = <any>'MATCHES',
        DATERANGE = <any>'DATE_RANGE'
    }
}
export class ChildResult {
    'children'?: Array<Record>;
    'parent'?: Record;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "children",
            "baseName": "children",
            "type": "Array<Record>"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "Record"
        }];

    static getAttributeTypeMap() {
        return ChildResult.attributeTypeMap;
    }
}

export class CleanAttachment extends CurrentValue {
    'active'?: boolean;
    'archived'?: boolean;
    'attachmentStatus'?: CleanAttachment.AttachmentStatusEnum;
    'awsS3Key'?: string;
    'contentType'?: string;
    'created'?: Date;
    '_default'?: boolean;
    'discriminator'?: string;
    'empty'?: boolean;
    'field'?: Field;
    'fieldId'?: string;
    'fileExtension'?: string;
    'fileSize'?: number;
    'hasValue'?: Field;
    'id'?: string;
    'isDefault'?: boolean;
    'labels'?: Array<string>;
    'numericValue'?: number;
    'originalFileExtension'?: string;
    'priority'?: number;
    'textValue'?: string;
    'updated'?: Date;
    'valueType'?: string;
    'versionCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "attachmentStatus",
            "baseName": "attachmentStatus",
            "type": "CleanAttachment.AttachmentStatusEnum"
        },
        {
            "name": "awsS3Key",
            "baseName": "awsS3Key",
            "type": "string"
        },
        {
            "name": "contentType",
            "baseName": "contentType",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "discriminator",
            "baseName": "discriminator",
            "type": "string"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        },
        {
            "name": "fileExtension",
            "baseName": "fileExtension",
            "type": "string"
        },
        {
            "name": "fileSize",
            "baseName": "fileSize",
            "type": "number"
        },
        {
            "name": "hasValue",
            "baseName": "hasValue",
            "type": "Field"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isDefault",
            "baseName": "isDefault",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "numericValue",
            "baseName": "numericValue",
            "type": "number"
        },
        {
            "name": "originalFileExtension",
            "baseName": "originalFileExtension",
            "type": "string"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "textValue",
            "baseName": "textValue",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        },
        {
            "name": "versionCount",
            "baseName": "versionCount",
            "type": "number"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CleanAttachment.attributeTypeMap);
    }
}

export namespace CleanAttachment {
    export enum AttachmentStatusEnum {
        PENDING = <any>'PENDING',
        CLEAN = <any>'CLEAN',
        DIRTY = <any>'DIRTY'
    }
}
export class CurrentCommonValue extends CurrentValue {
    'active'?: boolean;
    'archived'?: boolean;
    'created'?: Date;
    '_default'?: boolean;
    'discriminator'?: string;
    'empty'?: boolean;
    'field'?: Field;
    'fieldId'?: string;
    'hasValue'?: Field;
    'id'?: string;
    'isDefault'?: boolean;
    'labels'?: Array<string>;
    'numericValue'?: number;
    'priority'?: number;
    'textValue'?: string;
    'updated'?: Date;
    'valueType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "discriminator",
            "baseName": "discriminator",
            "type": "string"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        },
        {
            "name": "hasValue",
            "baseName": "hasValue",
            "type": "Field"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isDefault",
            "baseName": "isDefault",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "numericValue",
            "baseName": "numericValue",
            "type": "number"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "textValue",
            "baseName": "textValue",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CurrentCommonValue.attributeTypeMap);
    }
}

export class CurrentDateRangeValue extends CurrentValue {
    'active'?: boolean;
    'archived'?: boolean;
    'created'?: Date;
    '_default'?: boolean;
    'defaultToNow'?: boolean;
    'discriminator'?: string;
    'empty'?: boolean;
    'endTemporalValue'?: Date;
    'field'?: Field;
    'fieldId'?: string;
    'hasTime'?: boolean;
    'hasValue'?: Field;
    'id'?: string;
    'isDefault'?: boolean;
    'labels'?: Array<string>;
    'numericValue'?: number;
    'priority'?: number;
    'temporalValue'?: Date;
    'textValue'?: string;
    'updated'?: Date;
    'valueType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "defaultToNow",
            "baseName": "defaultToNow",
            "type": "boolean"
        },
        {
            "name": "discriminator",
            "baseName": "discriminator",
            "type": "string"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        },
        {
            "name": "endTemporalValue",
            "baseName": "endTemporalValue",
            "type": "Date"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        },
        {
            "name": "hasTime",
            "baseName": "hasTime",
            "type": "boolean"
        },
        {
            "name": "hasValue",
            "baseName": "hasValue",
            "type": "Field"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isDefault",
            "baseName": "isDefault",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "numericValue",
            "baseName": "numericValue",
            "type": "number"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "temporalValue",
            "baseName": "temporalValue",
            "type": "Date"
        },
        {
            "name": "textValue",
            "baseName": "textValue",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CurrentDateRangeValue.attributeTypeMap);
    }
}

export class CurrentDateValue extends CurrentValue {
    'active'?: boolean;
    'archived'?: boolean;
    'created'?: Date;
    '_default'?: boolean;
    'defaultToNow'?: boolean;
    'discriminator'?: string;
    'empty'?: boolean;
    'field'?: Field;
    'fieldId'?: string;
    'hasTime'?: boolean;
    'hasValue'?: Field;
    'id'?: string;
    'isDefault'?: boolean;
    'labels'?: Array<string>;
    'numericValue'?: number;
    'priority'?: number;
    'temporalValue'?: Date;
    'textValue'?: string;
    'updated'?: Date;
    'valueType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "defaultToNow",
            "baseName": "defaultToNow",
            "type": "boolean"
        },
        {
            "name": "discriminator",
            "baseName": "discriminator",
            "type": "string"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        },
        {
            "name": "hasTime",
            "baseName": "hasTime",
            "type": "boolean"
        },
        {
            "name": "hasValue",
            "baseName": "hasValue",
            "type": "Field"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isDefault",
            "baseName": "isDefault",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "numericValue",
            "baseName": "numericValue",
            "type": "number"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "temporalValue",
            "baseName": "temporalValue",
            "type": "Date"
        },
        {
            "name": "textValue",
            "baseName": "textValue",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CurrentDateValue.attributeTypeMap);
    }
}



export class DatePicker extends Field {
    'active'?: boolean;
    'convertibleTo'?: Array<string>;
    'created'?: Date;
    /**
    * Relationship to current values that are associated to the field.
    */
    'currentValues'?: Array<CurrentValue>;
    'discrete'?: boolean;
    'fieldType': DatePicker.FieldTypeEnum;
    'global'?: boolean;
    'hasTime'?: boolean;
    'id'?: string;
    /**
    * The label will appear as the label for the field when it appears on forms for user's to complete.
    */
    'label'?: string;
    'labels'?: Array<string>;
    /**
    * The name of the field.
    */
    'name'?: string;
    'operators'?: Array<DatePicker.OperatorsEnum>;
    'presentOrFuture'?: boolean;
    'presentOrPast'?: boolean;
    /**
    * A text value that will populate any tooltip information.
    */
    'tooltip'?: string;
    'updated'?: Date;
    'valueType'?: string;
    /**
    * Workflow object that is associated to the field.
    */
    'workflow'?: Workflow;
    'workflowId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "convertibleTo",
            "baseName": "convertibleTo",
            "type": "Array<string>"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "currentValues",
            "baseName": "currentValues",
            "type": "Array<CurrentValue>"
        },
        {
            "name": "discrete",
            "baseName": "discrete",
            "type": "boolean"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "DatePicker.FieldTypeEnum"
        },
        {
            "name": "global",
            "baseName": "global",
            "type": "boolean"
        },
        {
            "name": "hasTime",
            "baseName": "hasTime",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "operators",
            "baseName": "operators",
            "type": "Array<DatePicker.OperatorsEnum>"
        },
        {
            "name": "presentOrFuture",
            "baseName": "presentOrFuture",
            "type": "boolean"
        },
        {
            "name": "presentOrPast",
            "baseName": "presentOrPast",
            "type": "boolean"
        },
        {
            "name": "tooltip",
            "baseName": "tooltip",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DatePicker.attributeTypeMap);
    }
}

export namespace DatePicker {
    export enum FieldTypeEnum {
        TEXT = <any>'TEXT',
        TEXTAREA = <any>'TEXT_AREA',
        DATEPICKER = <any>'DATE_PICKER',
        NUMBER = <any>'NUMBER',
        ESIGNATURE = <any>'E_SIGNATURE',
        CHECKBOX = <any>'CHECKBOX',
        MULTISELECT = <any>'MULTI_SELECT',
        RADIO = <any>'RADIO',
        SELECT = <any>'SELECT',
        USER = <any>'USER',
        ATTACHMENT = <any>'ATTACHMENT',
        CALCULATION = <any>'CALCULATION',
        DUEDATE = <any>'DUE_DATE'
    }
    export enum OperatorsEnum {
        EQUALS = <any>'EQUALS',
        NOTEQUALS = <any>'NOT_EQUALS',
        GREATERTHAN = <any>'GREATER_THAN',
        GREATERTHANEQUALS = <any>'GREATER_THAN_EQUALS',
        LESSTHAN = <any>'LESS_THAN',
        LESSTHANEQUALS = <any>'LESS_THAN_EQUALS',
        CONTAINS = <any>'CONTAINS',
        DOESNOTCONTAIN = <any>'DOES_NOT_CONTAIN',
        NULL = <any>'NULL',
        NOTNULL = <any>'NOT_NULL',
        MATCHES = <any>'MATCHES',
        DATERANGE = <any>'DATE_RANGE'
    }
}
export class DirtyAttachment extends CurrentValue {
    'active'?: boolean;
    'archived'?: boolean;
    'attachmentStatus'?: DirtyAttachment.AttachmentStatusEnum;
    'awsS3Key'?: string;
    'contentType'?: string;
    'created'?: Date;
    '_default'?: boolean;
    'discriminator'?: string;
    'empty'?: boolean;
    'field'?: Field;
    'fieldId'?: string;
    'fileExtension'?: string;
    'fileSize'?: number;
    'hasValue'?: Field;
    'id'?: string;
    'isDefault'?: boolean;
    'labels'?: Array<string>;
    'numericValue'?: number;
    'originalFileExtension'?: string;
    'priority'?: number;
    'textValue'?: string;
    'updated'?: Date;
    'valueType'?: string;
    'versionCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "attachmentStatus",
            "baseName": "attachmentStatus",
            "type": "DirtyAttachment.AttachmentStatusEnum"
        },
        {
            "name": "awsS3Key",
            "baseName": "awsS3Key",
            "type": "string"
        },
        {
            "name": "contentType",
            "baseName": "contentType",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "discriminator",
            "baseName": "discriminator",
            "type": "string"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        },
        {
            "name": "fileExtension",
            "baseName": "fileExtension",
            "type": "string"
        },
        {
            "name": "fileSize",
            "baseName": "fileSize",
            "type": "number"
        },
        {
            "name": "hasValue",
            "baseName": "hasValue",
            "type": "Field"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isDefault",
            "baseName": "isDefault",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "numericValue",
            "baseName": "numericValue",
            "type": "number"
        },
        {
            "name": "originalFileExtension",
            "baseName": "originalFileExtension",
            "type": "string"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "textValue",
            "baseName": "textValue",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        },
        {
            "name": "versionCount",
            "baseName": "versionCount",
            "type": "number"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DirtyAttachment.attributeTypeMap);
    }
}

export namespace DirtyAttachment {
    export enum AttachmentStatusEnum {
        PENDING = <any>'PENDING',
        CLEAN = <any>'CLEAN',
        DIRTY = <any>'DIRTY'
    }
}
export class Disabled extends User {
    'active'?: boolean;
    'archived'?: boolean;
    'assignments'?: Array<Record>;
    'company'?: string;
    'created'?: Date;
    '_default'?: boolean;
    'disabled'?: boolean;
    'discriminator'?: string;
    'email'?: string;
    'empty'?: boolean;
    'field'?: Field;
    'fieldId'?: string;
    'first'?: string;
    'hasValue'?: Field;
    'id'?: string;
    'imageUrl'?: string;
    'intercomHash'?: string;
    'isDefault'?: boolean;
    'labels'?: Array<string>;
    'languageTag'?: string;
    'last'?: string;
    'lastLogin'?: AccessAudit;
    'locked'?: boolean;
    'loginAttempts'?: number;
    'name'?: string;
    'numericValue'?: number;
    'password'?: string;
    'priority'?: number;
    'records'?: Array<Record>;
    'resetPasswordToken'?: string;
    'roles'?: Array<Role>;
    'sendEmail'?: boolean;
    'status'?: string;
    'superUser'?: boolean;
    'textValue'?: string;
    'tier'?: Disabled.TierEnum;
    'timeZone'?: string;
    'updated'?: Date;
    'valueType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "assignments",
            "baseName": "assignments",
            "type": "Array<Record>"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "disabled",
            "baseName": "disabled",
            "type": "boolean"
        },
        {
            "name": "discriminator",
            "baseName": "discriminator",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "string"
        },
        {
            "name": "hasValue",
            "baseName": "hasValue",
            "type": "Field"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "intercomHash",
            "baseName": "intercomHash",
            "type": "string"
        },
        {
            "name": "isDefault",
            "baseName": "isDefault",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "languageTag",
            "baseName": "languageTag",
            "type": "string"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "string"
        },
        {
            "name": "lastLogin",
            "baseName": "lastLogin",
            "type": "AccessAudit"
        },
        {
            "name": "locked",
            "baseName": "locked",
            "type": "boolean"
        },
        {
            "name": "loginAttempts",
            "baseName": "loginAttempts",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "numericValue",
            "baseName": "numericValue",
            "type": "number"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "records",
            "baseName": "records",
            "type": "Array<Record>"
        },
        {
            "name": "resetPasswordToken",
            "baseName": "resetPasswordToken",
            "type": "string"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<Role>"
        },
        {
            "name": "sendEmail",
            "baseName": "sendEmail",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "superUser",
            "baseName": "superUser",
            "type": "boolean"
        },
        {
            "name": "textValue",
            "baseName": "textValue",
            "type": "string"
        },
        {
            "name": "tier",
            "baseName": "tier",
            "type": "Disabled.TierEnum"
        },
        {
            "name": "timeZone",
            "baseName": "timeZone",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Disabled.attributeTypeMap);
    }
}

export namespace Disabled {
    export enum TierEnum {
        PRIMARY = <any>'PRIMARY',
        SECONDARY = <any>'SECONDARY',
        LIMITED = <any>'LIMITED'
    }
}
export class Display extends Layout {
    'active'?: boolean;
    'created'?: Date;
    'defaultLayout'?: boolean;
    'id'?: string;
    'labels'?: Array<string>;
    'layoutFields'?: Array<LayoutField>;
    'title'?: string;
    'updated'?: Date;
    'workflow'?: Workflow;
    'workflowId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "defaultLayout",
            "baseName": "defaultLayout",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "layoutFields",
            "baseName": "layoutFields",
            "type": "Array<LayoutField>"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Display.attributeTypeMap);
    }
}

export class DueDate extends Field {
    'active'?: boolean;
    'convertibleTo'?: Array<string>;
    'created'?: Date;
    /**
    * Relationship to current values that are associated to the field.
    */
    'currentValues'?: Array<CurrentValue>;
    'discrete'?: boolean;
    'fieldType': DueDate.FieldTypeEnum;
    'global'?: boolean;
    'id'?: string;
    /**
    * The label will appear as the label for the field when it appears on forms for user's to complete.
    */
    'label'?: string;
    'labels'?: Array<string>;
    /**
    * The name of the field.
    */
    'name'?: string;
    'operators'?: Array<DueDate.OperatorsEnum>;
    /**
    * A text value that will populate any tooltip information.
    */
    'tooltip'?: string;
    'updated'?: Date;
    'valueType'?: string;
    /**
    * Workflow object that is associated to the field.
    */
    'workflow'?: Workflow;
    'workflowId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "convertibleTo",
            "baseName": "convertibleTo",
            "type": "Array<string>"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "currentValues",
            "baseName": "currentValues",
            "type": "Array<CurrentValue>"
        },
        {
            "name": "discrete",
            "baseName": "discrete",
            "type": "boolean"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "DueDate.FieldTypeEnum"
        },
        {
            "name": "global",
            "baseName": "global",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "operators",
            "baseName": "operators",
            "type": "Array<DueDate.OperatorsEnum>"
        },
        {
            "name": "tooltip",
            "baseName": "tooltip",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DueDate.attributeTypeMap);
    }
}

export namespace DueDate {
    export enum FieldTypeEnum {
        TEXT = <any>'TEXT',
        TEXTAREA = <any>'TEXT_AREA',
        DATEPICKER = <any>'DATE_PICKER',
        NUMBER = <any>'NUMBER',
        ESIGNATURE = <any>'E_SIGNATURE',
        CHECKBOX = <any>'CHECKBOX',
        MULTISELECT = <any>'MULTI_SELECT',
        RADIO = <any>'RADIO',
        SELECT = <any>'SELECT',
        USER = <any>'USER',
        ATTACHMENT = <any>'ATTACHMENT',
        CALCULATION = <any>'CALCULATION',
        DUEDATE = <any>'DUE_DATE'
    }
    export enum OperatorsEnum {
        EQUALS = <any>'EQUALS',
        NOTEQUALS = <any>'NOT_EQUALS',
        GREATERTHAN = <any>'GREATER_THAN',
        GREATERTHANEQUALS = <any>'GREATER_THAN_EQUALS',
        LESSTHAN = <any>'LESS_THAN',
        LESSTHANEQUALS = <any>'LESS_THAN_EQUALS',
        CONTAINS = <any>'CONTAINS',
        DOESNOTCONTAIN = <any>'DOES_NOT_CONTAIN',
        NULL = <any>'NULL',
        NOTNULL = <any>'NOT_NULL',
        MATCHES = <any>'MATCHES',
        DATERANGE = <any>'DATE_RANGE'
    }
}
export class ESignature extends Field {
    'active'?: boolean;
    'convertibleTo'?: Array<string>;
    'created'?: Date;
    /**
    * Relationship to current values that are associated to the field.
    */
    'currentValues'?: Array<CurrentValue>;
    'discrete'?: boolean;
    'fieldType': ESignature.FieldTypeEnum;
    'global'?: boolean;
    'hasSignature'?: boolean;
    'id'?: string;
    /**
    * The label will appear as the label for the field when it appears on forms for user's to complete.
    */
    'label'?: string;
    'labels'?: Array<string>;
    /**
    * The name of the field.
    */
    'name'?: string;
    'operators'?: Array<ESignature.OperatorsEnum>;
    /**
    * A text value that will populate any tooltip information.
    */
    'tooltip'?: string;
    'updated'?: Date;
    'valueType'?: string;
    /**
    * Workflow object that is associated to the field.
    */
    'workflow'?: Workflow;
    'workflowId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "convertibleTo",
            "baseName": "convertibleTo",
            "type": "Array<string>"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "currentValues",
            "baseName": "currentValues",
            "type": "Array<CurrentValue>"
        },
        {
            "name": "discrete",
            "baseName": "discrete",
            "type": "boolean"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "ESignature.FieldTypeEnum"
        },
        {
            "name": "global",
            "baseName": "global",
            "type": "boolean"
        },
        {
            "name": "hasSignature",
            "baseName": "hasSignature",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "operators",
            "baseName": "operators",
            "type": "Array<ESignature.OperatorsEnum>"
        },
        {
            "name": "tooltip",
            "baseName": "tooltip",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ESignature.attributeTypeMap);
    }
}

export namespace ESignature {
    export enum FieldTypeEnum {
        TEXT = <any>'TEXT',
        TEXTAREA = <any>'TEXT_AREA',
        DATEPICKER = <any>'DATE_PICKER',
        NUMBER = <any>'NUMBER',
        ESIGNATURE = <any>'E_SIGNATURE',
        CHECKBOX = <any>'CHECKBOX',
        MULTISELECT = <any>'MULTI_SELECT',
        RADIO = <any>'RADIO',
        SELECT = <any>'SELECT',
        USER = <any>'USER',
        ATTACHMENT = <any>'ATTACHMENT',
        CALCULATION = <any>'CALCULATION',
        DUEDATE = <any>'DUE_DATE'
    }
    export enum OperatorsEnum {
        EQUALS = <any>'EQUALS',
        NOTEQUALS = <any>'NOT_EQUALS',
        GREATERTHAN = <any>'GREATER_THAN',
        GREATERTHANEQUALS = <any>'GREATER_THAN_EQUALS',
        LESSTHAN = <any>'LESS_THAN',
        LESSTHANEQUALS = <any>'LESS_THAN_EQUALS',
        CONTAINS = <any>'CONTAINS',
        DOESNOTCONTAIN = <any>'DOES_NOT_CONTAIN',
        NULL = <any>'NULL',
        NOTNULL = <any>'NOT_NULL',
        MATCHES = <any>'MATCHES',
        DATERANGE = <any>'DATE_RANGE'
    }
}
export class End extends Step {
    'active'?: boolean;
    /**
    * Allow entitlements to the node.
    */
    'allowEntitlements'?: boolean;
    'chain'?: boolean;
    'contains'?: Workflow;
    'created'?: Date;
    'end'?: boolean;
    'id'?: string;
    /**
    * Allows a node to become a public node.
    */
    'isPublic'?: boolean;
    'labels'?: Array<string>;
    /**
    * Node name.
    */
    'name'?: string;
    'origin'?: boolean;
    /**
    * Determines the node's place in the workflow.
    */
    'priority'?: number;
    '_public'?: boolean;
    /**
    * Object containing all SLA information.
    */
    'sla'?: ServiceLevelAgreement;
    /**
    * Node type.
    */
    'stepType'?: string;
    'updated'?: Date;
    /**
    * Workflow that the node belongs to.
    */
    'workflow'?: Workflow;
    'workflowId'?: string;
    /**
    * Vertical position of the node on the process screen.
    */
    'xpos'?: number;
    /**
    * Horizontal position of the node on the process screen.
    */
    'ypos'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "allowEntitlements",
            "baseName": "allowEntitlements",
            "type": "boolean"
        },
        {
            "name": "chain",
            "baseName": "chain",
            "type": "boolean"
        },
        {
            "name": "contains",
            "baseName": "contains",
            "type": "Workflow"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "end",
            "baseName": "end",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isPublic",
            "baseName": "isPublic",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "origin",
            "baseName": "origin",
            "type": "boolean"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "_public",
            "baseName": "public",
            "type": "boolean"
        },
        {
            "name": "sla",
            "baseName": "sla",
            "type": "ServiceLevelAgreement"
        },
        {
            "name": "stepType",
            "baseName": "stepType",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        },
        {
            "name": "xpos",
            "baseName": "xpos",
            "type": "number"
        },
        {
            "name": "ypos",
            "baseName": "ypos",
            "type": "number"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(End.attributeTypeMap);
    }
}

export class External extends User {
    'active'?: boolean;
    'archived'?: boolean;
    'assignments'?: Array<Record>;
    'company'?: string;
    'created'?: Date;
    '_default'?: boolean;
    'disabled'?: boolean;
    'discriminator'?: string;
    'email'?: string;
    'empty'?: boolean;
    'field'?: Field;
    'fieldId'?: string;
    'first'?: string;
    'hasValue'?: Field;
    'id'?: string;
    'imageUrl'?: string;
    'intercomHash'?: string;
    'isDefault'?: boolean;
    'labels'?: Array<string>;
    'languageTag'?: string;
    'last'?: string;
    'lastLogin'?: AccessAudit;
    'locked'?: boolean;
    'loginAttempts'?: number;
    'name'?: string;
    'numericValue'?: number;
    'password'?: string;
    'priority'?: number;
    'records'?: Array<Record>;
    'resetPasswordToken'?: string;
    'roles'?: Array<Role>;
    'sendEmail'?: boolean;
    'status'?: string;
    'superUser'?: boolean;
    'textValue'?: string;
    'tier'?: External.TierEnum;
    'timeZone'?: string;
    'updated'?: Date;
    'valueType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "assignments",
            "baseName": "assignments",
            "type": "Array<Record>"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "disabled",
            "baseName": "disabled",
            "type": "boolean"
        },
        {
            "name": "discriminator",
            "baseName": "discriminator",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "string"
        },
        {
            "name": "hasValue",
            "baseName": "hasValue",
            "type": "Field"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "intercomHash",
            "baseName": "intercomHash",
            "type": "string"
        },
        {
            "name": "isDefault",
            "baseName": "isDefault",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "languageTag",
            "baseName": "languageTag",
            "type": "string"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "string"
        },
        {
            "name": "lastLogin",
            "baseName": "lastLogin",
            "type": "AccessAudit"
        },
        {
            "name": "locked",
            "baseName": "locked",
            "type": "boolean"
        },
        {
            "name": "loginAttempts",
            "baseName": "loginAttempts",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "numericValue",
            "baseName": "numericValue",
            "type": "number"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "records",
            "baseName": "records",
            "type": "Array<Record>"
        },
        {
            "name": "resetPasswordToken",
            "baseName": "resetPasswordToken",
            "type": "string"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<Role>"
        },
        {
            "name": "sendEmail",
            "baseName": "sendEmail",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "superUser",
            "baseName": "superUser",
            "type": "boolean"
        },
        {
            "name": "textValue",
            "baseName": "textValue",
            "type": "string"
        },
        {
            "name": "tier",
            "baseName": "tier",
            "type": "External.TierEnum"
        },
        {
            "name": "timeZone",
            "baseName": "timeZone",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(External.attributeTypeMap);
    }
}

export namespace External {
    export enum TierEnum {
        PRIMARY = <any>'PRIMARY',
        SECONDARY = <any>'SECONDARY',
        LIMITED = <any>'LIMITED'
    }
}


export namespace Field {
    export enum FieldTypeEnum {
        TEXT = <any>'TEXT',
        TEXTAREA = <any>'TEXT_AREA',
        DATEPICKER = <any>'DATE_PICKER',
        NUMBER = <any>'NUMBER',
        ESIGNATURE = <any>'E_SIGNATURE',
        CHECKBOX = <any>'CHECKBOX',
        MULTISELECT = <any>'MULTI_SELECT',
        RADIO = <any>'RADIO',
        SELECT = <any>'SELECT',
        USER = <any>'USER',
        ATTACHMENT = <any>'ATTACHMENT',
        CALCULATION = <any>'CALCULATION',
        DUEDATE = <any>'DUE_DATE'
    }
    export enum OperatorsEnum {
        EQUALS = <any>'EQUALS',
        NOTEQUALS = <any>'NOT_EQUALS',
        GREATERTHAN = <any>'GREATER_THAN',
        GREATERTHANEQUALS = <any>'GREATER_THAN_EQUALS',
        LESSTHAN = <any>'LESS_THAN',
        LESSTHANEQUALS = <any>'LESS_THAN_EQUALS',
        CONTAINS = <any>'CONTAINS',
        DOESNOTCONTAIN = <any>'DOES_NOT_CONTAIN',
        NULL = <any>'NULL',
        NOTNULL = <any>'NOT_NULL',
        MATCHES = <any>'MATCHES',
        DATERANGE = <any>'DATE_RANGE'
    }
}
/**
* A relationship object managing how to use fields and their associated current value maps in an expression.
*/
export class FieldInput {
    'active'?: boolean;
    'created'?: Date;
    'fieldResult'?: FieldInputResult;
    'id'?: string;
    /**
    * Field input to be used in the parent field's expression
    */
    'input'?: Field;
    'inputId'?: string;
    'labels'?: Array<string>;
    /**
    * Parent field that will use the input field in the expression.
    */
    'parent'?: Field;
    /**
    * Determines the fields place within the expression.
    */
    'priority'?: number;
    'updated'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "fieldResult",
            "baseName": "fieldResult",
            "type": "FieldInputResult"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "input",
            "baseName": "input",
            "type": "Field"
        },
        {
            "name": "inputId",
            "baseName": "inputId",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "Field"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }];

    static getAttributeTypeMap() {
        return FieldInput.attributeTypeMap;
    }
}

export class FieldInputResult {
    'fieldType'?: string;
    'id'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return FieldInputResult.attributeTypeMap;
    }
}

export class FilteredRecord {
    'assignment'?: RecordDetails;
    'properties'?: Array<RecordProperty>;
    'record'?: RecordDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "assignment",
            "baseName": "assignment",
            "type": "RecordDetails"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "Array<RecordProperty>"
        },
        {
            "name": "record",
            "baseName": "record",
            "type": "RecordDetails"
        }];

    static getAttributeTypeMap() {
        return FilteredRecord.attributeTypeMap;
    }
}

export class GraphEntity {
    'active'?: boolean;
    'created'?: Date;
    'id'?: string;
    'labels'?: Array<string>;
    'updated'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }];

    static getAttributeTypeMap() {
        return GraphEntity.attributeTypeMap;
    }
}

export class ImportRecordRequest extends ImportRequest {
    'active'?: boolean;
    'created'?: Date;
    'id'?: string;
    'importType'?: string;
    'labels'?: Array<string>;
    'layout'?: Layout;
    'targetStep'?: Step;
    'updated'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "importType",
            "baseName": "importType",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "layout",
            "baseName": "layout",
            "type": "Layout"
        },
        {
            "name": "targetStep",
            "baseName": "targetStep",
            "type": "Step"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImportRecordRequest.attributeTypeMap);
    }
}



export class ImportUserRequest extends ImportRequest {
    'active'?: boolean;
    'created'?: Date;
    'id'?: string;
    'importType'?: string;
    'labels'?: Array<string>;
    'updated'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "importType",
            "baseName": "importType",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImportUserRequest.attributeTypeMap);
    }
}

export class InputStream {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    ];

    static getAttributeTypeMap() {
        return InputStream.attributeTypeMap;
    }
}

export class LabelValue extends CurrentValue {
    'active'?: boolean;
    'archived'?: boolean;
    'color'?: string;
    'created'?: Date;
    '_default'?: boolean;
    'discriminator'?: string;
    'empty'?: boolean;
    'field'?: Field;
    'fieldId'?: string;
    'hasValue'?: Field;
    'icon'?: string;
    'id'?: string;
    'isDefault'?: boolean;
    'labels'?: Array<string>;
    'numericValue'?: number;
    'priority'?: number;
    'textValue'?: string;
    'updated'?: Date;
    'valueType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "discriminator",
            "baseName": "discriminator",
            "type": "string"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        },
        {
            "name": "hasValue",
            "baseName": "hasValue",
            "type": "Field"
        },
        {
            "name": "icon",
            "baseName": "icon",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isDefault",
            "baseName": "isDefault",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "numericValue",
            "baseName": "numericValue",
            "type": "number"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "textValue",
            "baseName": "textValue",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LabelValue.attributeTypeMap);
    }
}



export class LayoutField {
    'active'?: boolean;
    'category'?: LayoutField.CategoryEnum;
    'created'?: Date;
    'direction'?: LayoutField.DirectionEnum;
    'field'?: Field;
    'fieldId'?: string;
    'header'?: string;
    'headerOrFieldName'?: string;
    'id'?: string;
    'labelDisplayType'?: LayoutField.LabelDisplayTypeEnum;
    'labels'?: Array<string>;
    'layoutId'?: string;
    'link'?: boolean;
    'operators'?: Array<LayoutField.OperatorsEnum>;
    'priority'?: number;
    'sortProperty'?: string;
    'sortable'?: boolean;
    'systemField'?: LayoutField.SystemFieldEnum;
    'toDelete'?: boolean;
    'updated'?: Date;
    'workflow'?: Workflow;
    'workflowId'?: string;
    'workflowMap'?: WorkflowMap;
    'workflowMapId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "LayoutField.CategoryEnum"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "direction",
            "baseName": "direction",
            "type": "LayoutField.DirectionEnum"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        },
        {
            "name": "header",
            "baseName": "header",
            "type": "string"
        },
        {
            "name": "headerOrFieldName",
            "baseName": "headerOrFieldName",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labelDisplayType",
            "baseName": "labelDisplayType",
            "type": "LayoutField.LabelDisplayTypeEnum"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "layoutId",
            "baseName": "layoutId",
            "type": "string"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "boolean"
        },
        {
            "name": "operators",
            "baseName": "operators",
            "type": "Array<LayoutField.OperatorsEnum>"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "sortProperty",
            "baseName": "sortProperty",
            "type": "string"
        },
        {
            "name": "sortable",
            "baseName": "sortable",
            "type": "boolean"
        },
        {
            "name": "systemField",
            "baseName": "systemField",
            "type": "LayoutField.SystemFieldEnum"
        },
        {
            "name": "toDelete",
            "baseName": "toDelete",
            "type": "boolean"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        },
        {
            "name": "workflowMap",
            "baseName": "workflowMap",
            "type": "WorkflowMap"
        },
        {
            "name": "workflowMapId",
            "baseName": "workflowMapId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return LayoutField.attributeTypeMap;
    }
}

export namespace LayoutField {
    export enum CategoryEnum {
        RECORD = <any>'RECORD',
        USERS = <any>'USERS',
        PROCESS = <any>'PROCESS',
        WORKFLOW = <any>'WORKFLOW',
        GLOBAL = <any>'GLOBAL'
    }
    export enum DirectionEnum {
        ASC = <any>'ASC',
        DESC = <any>'DESC'
    }
    export enum LabelDisplayTypeEnum {
        VALUE = <any>'VALUE',
        LABEL = <any>'LABEL',
        ALL = <any>'ALL'
    }
    export enum OperatorsEnum {
        EQUALS = <any>'EQUALS',
        NOTEQUALS = <any>'NOT_EQUALS',
        GREATERTHAN = <any>'GREATER_THAN',
        GREATERTHANEQUALS = <any>'GREATER_THAN_EQUALS',
        LESSTHAN = <any>'LESS_THAN',
        LESSTHANEQUALS = <any>'LESS_THAN_EQUALS',
        CONTAINS = <any>'CONTAINS',
        DOESNOTCONTAIN = <any>'DOES_NOT_CONTAIN',
        NULL = <any>'NULL',
        NOTNULL = <any>'NOT_NULL',
        MATCHES = <any>'MATCHES',
        DATERANGE = <any>'DATE_RANGE'
    }
    export enum SystemFieldEnum {
        NAME = <any>'NAME',
        STATUS = <any>'STATUS',
        CREATED = <any>'CREATED',
        USERDATE = <any>'USER_DATE',
        EFFECTIVEDUEDATE = <any>'EFFECTIVE_DUE_DATE',
        DUEDATE = <any>'DUE_DATE',
        ID = <any>'ID',
        USERNAME = <any>'USER_NAME',
        USERID = <any>'USER_ID',
        CREATORNAME = <any>'CREATOR_NAME',
        USERGROUP = <any>'USER_GROUP',
        STEPNAME = <any>'STEP_NAME',
        STEPID = <any>'STEP_ID',
        ORIGINNAME = <any>'ORIGIN_NAME',
        WORKFLOWNAME = <any>'WORKFLOW_NAME',
        WORKFLOWRECORDPREFIX = <any>'WORKFLOW_RECORD_PREFIX',
        WORKFLOWID = <any>'WORKFLOW_ID'
    }
}
export class Locked extends User {
    'active'?: boolean;
    'archived'?: boolean;
    'assignments'?: Array<Record>;
    'company'?: string;
    'created'?: Date;
    '_default'?: boolean;
    'disabled'?: boolean;
    'discriminator'?: string;
    'email'?: string;
    'empty'?: boolean;
    'field'?: Field;
    'fieldId'?: string;
    'first'?: string;
    'hasValue'?: Field;
    'id'?: string;
    'imageUrl'?: string;
    'intercomHash'?: string;
    'isDefault'?: boolean;
    'labels'?: Array<string>;
    'languageTag'?: string;
    'last'?: string;
    'lastLogin'?: AccessAudit;
    'locked'?: boolean;
    'loginAttempts'?: number;
    'name'?: string;
    'numericValue'?: number;
    'password'?: string;
    'priority'?: number;
    'records'?: Array<Record>;
    'resetPasswordToken'?: string;
    'roles'?: Array<Role>;
    'sendEmail'?: boolean;
    'status'?: string;
    'superUser'?: boolean;
    'textValue'?: string;
    'tier'?: Locked.TierEnum;
    'timeZone'?: string;
    'updated'?: Date;
    'valueType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "assignments",
            "baseName": "assignments",
            "type": "Array<Record>"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "disabled",
            "baseName": "disabled",
            "type": "boolean"
        },
        {
            "name": "discriminator",
            "baseName": "discriminator",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "string"
        },
        {
            "name": "hasValue",
            "baseName": "hasValue",
            "type": "Field"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "intercomHash",
            "baseName": "intercomHash",
            "type": "string"
        },
        {
            "name": "isDefault",
            "baseName": "isDefault",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "languageTag",
            "baseName": "languageTag",
            "type": "string"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "string"
        },
        {
            "name": "lastLogin",
            "baseName": "lastLogin",
            "type": "AccessAudit"
        },
        {
            "name": "locked",
            "baseName": "locked",
            "type": "boolean"
        },
        {
            "name": "loginAttempts",
            "baseName": "loginAttempts",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "numericValue",
            "baseName": "numericValue",
            "type": "number"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "records",
            "baseName": "records",
            "type": "Array<Record>"
        },
        {
            "name": "resetPasswordToken",
            "baseName": "resetPasswordToken",
            "type": "string"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<Role>"
        },
        {
            "name": "sendEmail",
            "baseName": "sendEmail",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "superUser",
            "baseName": "superUser",
            "type": "boolean"
        },
        {
            "name": "textValue",
            "baseName": "textValue",
            "type": "string"
        },
        {
            "name": "tier",
            "baseName": "tier",
            "type": "Locked.TierEnum"
        },
        {
            "name": "timeZone",
            "baseName": "timeZone",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Locked.attributeTypeMap);
    }
}

export namespace Locked {
    export enum TierEnum {
        PRIMARY = <any>'PRIMARY',
        SECONDARY = <any>'SECONDARY',
        LIMITED = <any>'LIMITED'
    }
}
export class LogIn extends AccessAudit {
    'active'?: boolean;
    'created'?: Date;
    'id'?: string;
    'labels'?: Array<string>;
    'remoteAddress'?: string;
    'updated'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "remoteAddress",
            "baseName": "remoteAddress",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LogIn.attributeTypeMap);
    }
}

export class LogInFail extends AccessAudit {
    'active'?: boolean;
    'created'?: Date;
    'id'?: string;
    'labels'?: Array<string>;
    'remoteAddress'?: string;
    'updated'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "remoteAddress",
            "baseName": "remoteAddress",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LogInFail.attributeTypeMap);
    }
}

export class LogOut extends AccessAudit {
    'active'?: boolean;
    'created'?: Date;
    'id'?: string;
    'labels'?: Array<string>;
    'remoteAddress'?: string;
    'updated'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "remoteAddress",
            "baseName": "remoteAddress",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LogOut.attributeTypeMap);
    }
}



export class ManyToOne extends WorkflowMap {
    'active'?: boolean;
    'childId'?: string;
    'created'?: Date;
    'id'?: string;
    'labels'?: Array<string>;
    'parentId'?: string;
    'parentResult'?: WorkflowResult;
    /**
    * Parent workflow.
    */
    'parentWorkflow'?: Workflow;
    'updated'?: Date;
    /**
    * Child workflow to be connected.
    */
    'workflow'?: Workflow;
    'workflowMapType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "childId",
            "baseName": "childId",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "string"
        },
        {
            "name": "parentResult",
            "baseName": "parentResult",
            "type": "WorkflowResult"
        },
        {
            "name": "parentWorkflow",
            "baseName": "parentWorkflow",
            "type": "Workflow"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowMapType",
            "baseName": "workflowMapType",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ManyToOne.attributeTypeMap);
    }
}

/**
* The \"default\" layout functions as the application's fallback when there is no workflow specific layout to use or a user specific layout to use.
*/
export class ModelDefault extends Layout {
    'active'?: boolean;
    'created'?: Date;
    'defaultLayout'?: boolean;
    'id'?: string;
    'labels'?: Array<string>;
    'layoutFields'?: Array<LayoutField>;
    'title'?: string;
    'updated'?: Date;
    'workflow'?: Workflow;
    'workflowId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "defaultLayout",
            "baseName": "defaultLayout",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "layoutFields",
            "baseName": "layoutFields",
            "type": "Array<LayoutField>"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ModelDefault.attributeTypeMap);
    }
}

export class ModelFile {
    'absolute'?: boolean;
    'absoluteFile'?: any;
    'absolutePath'?: string;
    'canonicalFile'?: any;
    'canonicalPath'?: string;
    'directory'?: boolean;
    'executable'?: boolean;
    'file'?: boolean;
    'freeSpace'?: number;
    'hidden'?: boolean;
    'lastModified'?: number;
    'name'?: string;
    'parent'?: string;
    'parentFile'?: any;
    'path'?: string;
    'readable'?: boolean;
    'totalSpace'?: number;
    'usableSpace'?: number;
    'writable'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "absolute",
            "baseName": "absolute",
            "type": "boolean"
        },
        {
            "name": "absoluteFile",
            "baseName": "absoluteFile",
            "type": "any"
        },
        {
            "name": "absolutePath",
            "baseName": "absolutePath",
            "type": "string"
        },
        {
            "name": "canonicalFile",
            "baseName": "canonicalFile",
            "type": "any"
        },
        {
            "name": "canonicalPath",
            "baseName": "canonicalPath",
            "type": "string"
        },
        {
            "name": "directory",
            "baseName": "directory",
            "type": "boolean"
        },
        {
            "name": "executable",
            "baseName": "executable",
            "type": "boolean"
        },
        {
            "name": "file",
            "baseName": "file",
            "type": "boolean"
        },
        {
            "name": "freeSpace",
            "baseName": "freeSpace",
            "type": "number"
        },
        {
            "name": "hidden",
            "baseName": "hidden",
            "type": "boolean"
        },
        {
            "name": "lastModified",
            "baseName": "lastModified",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "string"
        },
        {
            "name": "parentFile",
            "baseName": "parentFile",
            "type": "any"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "readable",
            "baseName": "readable",
            "type": "boolean"
        },
        {
            "name": "totalSpace",
            "baseName": "totalSpace",
            "type": "number"
        },
        {
            "name": "usableSpace",
            "baseName": "usableSpace",
            "type": "number"
        },
        {
            "name": "writable",
            "baseName": "writable",
            "type": "boolean"
        }];

    static getAttributeTypeMap() {
        return ModelFile.attributeTypeMap;
    }
}

export class Module {
    'active'?: boolean;
    'created'?: Date;
    'id'?: string;
    'labels'?: Array<string>;
    'name'?: string;
    'onlyUse'?: boolean;
    'tab'?: string;
    'updated'?: Date;
    'value'?: Module.ValueEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "onlyUse",
            "baseName": "onlyUse",
            "type": "boolean"
        },
        {
            "name": "tab",
            "baseName": "tab",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "Module.ValueEnum"
        }];

    static getAttributeTypeMap() {
        return Module.attributeTypeMap;
    }
}

export namespace Module {
    export enum ValueEnum {
        AASSIGN = <any>'A_ASSIGN',
        AIMPORT = <any>'A_IMPORT',
        AALLFIELDS = <any>'A_ALL_FIELDS',
        ABUILD = <any>'A_BUILD',
        AAPIACCESS = <any>'A_API_ACCESS',
        RRECORDS = <any>'R_RECORDS',
        RSTATUS = <any>'R_STATUS',
        RPRODUCTIVITY = <any>'R_PRODUCTIVITY',
        RTABLEREPORTS = <any>'R_TABLE_REPORTS',
        RDASHBOARDS = <any>'R_DASHBOARDS',
        ADMINALL = <any>'ADMIN_ALL'
    }
}
export class ModuleEntitlement {
    'active'?: boolean;
    'created'?: Date;
    'id'?: string;
    'labels'?: Array<string>;
    'module'?: Module;
    'operationType'?: string;
    'role'?: Role;
    'updated'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "module",
            "baseName": "module",
            "type": "Module"
        },
        {
            "name": "operationType",
            "baseName": "operationType",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "Role"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }];

    static getAttributeTypeMap() {
        return ModuleEntitlement.attributeTypeMap;
    }
}

export class MultiSelect extends Field {
    'active'?: boolean;
    'convertibleTo'?: Array<string>;
    'created'?: Date;
    /**
    * Relationship to current values that are associated to the field.
    */
    'currentValues'?: Array<CurrentValue>;
    'discrete'?: boolean;
    'fieldType': MultiSelect.FieldTypeEnum;
    'global'?: boolean;
    'id'?: string;
    /**
    * The label will appear as the label for the field when it appears on forms for user's to complete.
    */
    'label'?: string;
    'labels'?: Array<string>;
    /**
    * The name of the field.
    */
    'name'?: string;
    'operators'?: Array<MultiSelect.OperatorsEnum>;
    /**
    * A text value that will populate any tooltip information.
    */
    'tooltip'?: string;
    'updated'?: Date;
    'valueType'?: string;
    /**
    * Workflow object that is associated to the field.
    */
    'workflow'?: Workflow;
    'workflowId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "convertibleTo",
            "baseName": "convertibleTo",
            "type": "Array<string>"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "currentValues",
            "baseName": "currentValues",
            "type": "Array<CurrentValue>"
        },
        {
            "name": "discrete",
            "baseName": "discrete",
            "type": "boolean"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "MultiSelect.FieldTypeEnum"
        },
        {
            "name": "global",
            "baseName": "global",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "operators",
            "baseName": "operators",
            "type": "Array<MultiSelect.OperatorsEnum>"
        },
        {
            "name": "tooltip",
            "baseName": "tooltip",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(MultiSelect.attributeTypeMap);
    }
}

export namespace MultiSelect {
    export enum FieldTypeEnum {
        TEXT = <any>'TEXT',
        TEXTAREA = <any>'TEXT_AREA',
        DATEPICKER = <any>'DATE_PICKER',
        NUMBER = <any>'NUMBER',
        ESIGNATURE = <any>'E_SIGNATURE',
        CHECKBOX = <any>'CHECKBOX',
        MULTISELECT = <any>'MULTI_SELECT',
        RADIO = <any>'RADIO',
        SELECT = <any>'SELECT',
        USER = <any>'USER',
        ATTACHMENT = <any>'ATTACHMENT',
        CALCULATION = <any>'CALCULATION',
        DUEDATE = <any>'DUE_DATE'
    }
    export enum OperatorsEnum {
        EQUALS = <any>'EQUALS',
        NOTEQUALS = <any>'NOT_EQUALS',
        GREATERTHAN = <any>'GREATER_THAN',
        GREATERTHANEQUALS = <any>'GREATER_THAN_EQUALS',
        LESSTHAN = <any>'LESS_THAN',
        LESSTHANEQUALS = <any>'LESS_THAN_EQUALS',
        CONTAINS = <any>'CONTAINS',
        DOESNOTCONTAIN = <any>'DOES_NOT_CONTAIN',
        NULL = <any>'NULL',
        NOTNULL = <any>'NOT_NULL',
        MATCHES = <any>'MATCHES',
        DATERANGE = <any>'DATE_RANGE'
    }
}
export class Number extends Field {
    'active'?: boolean;
    'convertibleTo'?: Array<string>;
    'created'?: Date;
    /**
    * Relationship to current values that are associated to the field.
    */
    'currentValues'?: Array<CurrentValue>;
    'discrete'?: boolean;
    'fieldType': Number.FieldTypeEnum;
    'global'?: boolean;
    'id'?: string;
    /**
    * The label will appear as the label for the field when it appears on forms for user's to complete.
    */
    'label'?: string;
    'labels'?: Array<string>;
    'message'?: string;
    /**
    * The name of the field.
    */
    'name'?: string;
    'operators'?: Array<Number.OperatorsEnum>;
    'pattern'?: string;
    /**
    * A text value that will populate any tooltip information.
    */
    'tooltip'?: string;
    'updated'?: Date;
    'valueType'?: string;
    /**
    * Workflow object that is associated to the field.
    */
    'workflow'?: Workflow;
    'workflowId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "convertibleTo",
            "baseName": "convertibleTo",
            "type": "Array<string>"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "currentValues",
            "baseName": "currentValues",
            "type": "Array<CurrentValue>"
        },
        {
            "name": "discrete",
            "baseName": "discrete",
            "type": "boolean"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "Number.FieldTypeEnum"
        },
        {
            "name": "global",
            "baseName": "global",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "operators",
            "baseName": "operators",
            "type": "Array<Number.OperatorsEnum>"
        },
        {
            "name": "pattern",
            "baseName": "pattern",
            "type": "string"
        },
        {
            "name": "tooltip",
            "baseName": "tooltip",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Number.attributeTypeMap);
    }
}

export namespace Number {
    export enum FieldTypeEnum {
        TEXT = <any>'TEXT',
        TEXTAREA = <any>'TEXT_AREA',
        DATEPICKER = <any>'DATE_PICKER',
        NUMBER = <any>'NUMBER',
        ESIGNATURE = <any>'E_SIGNATURE',
        CHECKBOX = <any>'CHECKBOX',
        MULTISELECT = <any>'MULTI_SELECT',
        RADIO = <any>'RADIO',
        SELECT = <any>'SELECT',
        USER = <any>'USER',
        ATTACHMENT = <any>'ATTACHMENT',
        CALCULATION = <any>'CALCULATION',
        DUEDATE = <any>'DUE_DATE'
    }
    export enum OperatorsEnum {
        EQUALS = <any>'EQUALS',
        NOTEQUALS = <any>'NOT_EQUALS',
        GREATERTHAN = <any>'GREATER_THAN',
        GREATERTHANEQUALS = <any>'GREATER_THAN_EQUALS',
        LESSTHAN = <any>'LESS_THAN',
        LESSTHANEQUALS = <any>'LESS_THAN_EQUALS',
        CONTAINS = <any>'CONTAINS',
        DOESNOTCONTAIN = <any>'DOES_NOT_CONTAIN',
        NULL = <any>'NULL',
        NOTNULL = <any>'NOT_NULL',
        MATCHES = <any>'MATCHES',
        DATERANGE = <any>'DATE_RANGE'
    }
}
export class OneToMany extends WorkflowMap {
    'active'?: boolean;
    'childId'?: string;
    'created'?: Date;
    'id'?: string;
    'labels'?: Array<string>;
    'parentId'?: string;
    'parentResult'?: WorkflowResult;
    /**
    * Parent workflow.
    */
    'parentWorkflow'?: Workflow;
    'updated'?: Date;
    /**
    * Child workflow to be connected.
    */
    'workflow'?: Workflow;
    'workflowMapType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "childId",
            "baseName": "childId",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "string"
        },
        {
            "name": "parentResult",
            "baseName": "parentResult",
            "type": "WorkflowResult"
        },
        {
            "name": "parentWorkflow",
            "baseName": "parentWorkflow",
            "type": "Workflow"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowMapType",
            "baseName": "workflowMapType",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(OneToMany.attributeTypeMap);
    }
}

export class OneToOne extends WorkflowMap {
    'active'?: boolean;
    'childId'?: string;
    'created'?: Date;
    'id'?: string;
    'labels'?: Array<string>;
    'parentId'?: string;
    'parentResult'?: WorkflowResult;
    /**
    * Parent workflow.
    */
    'parentWorkflow'?: Workflow;
    'updated'?: Date;
    /**
    * Child workflow to be connected.
    */
    'workflow'?: Workflow;
    'workflowMapType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "childId",
            "baseName": "childId",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "string"
        },
        {
            "name": "parentResult",
            "baseName": "parentResult",
            "type": "WorkflowResult"
        },
        {
            "name": "parentWorkflow",
            "baseName": "parentWorkflow",
            "type": "Workflow"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowMapType",
            "baseName": "workflowMapType",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(OneToOne.attributeTypeMap);
    }
}

export class Origin extends Step {
    'active'?: boolean;
    /**
    * Allow entitlements to the node.
    */
    'allowEntitlements'?: boolean;
    'chain'?: boolean;
    'contains'?: Workflow;
    'created'?: Date;
    'end'?: boolean;
    'id'?: string;
    /**
    * Allows a node to become a public node.
    */
    'isPublic'?: boolean;
    'labels'?: Array<string>;
    /**
    * Node name.
    */
    'name'?: string;
    'origin'?: boolean;
    /**
    * Determines the node's place in the workflow.
    */
    'priority'?: number;
    '_public'?: boolean;
    /**
    * Object containing all SLA information.
    */
    'sla'?: ServiceLevelAgreement;
    /**
    * Node type.
    */
    'stepType'?: string;
    'updated'?: Date;
    /**
    * Workflow that the node belongs to.
    */
    'workflow'?: Workflow;
    'workflowId'?: string;
    /**
    * Vertical position of the node on the process screen.
    */
    'xpos'?: number;
    /**
    * Horizontal position of the node on the process screen.
    */
    'ypos'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "allowEntitlements",
            "baseName": "allowEntitlements",
            "type": "boolean"
        },
        {
            "name": "chain",
            "baseName": "chain",
            "type": "boolean"
        },
        {
            "name": "contains",
            "baseName": "contains",
            "type": "Workflow"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "end",
            "baseName": "end",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isPublic",
            "baseName": "isPublic",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "origin",
            "baseName": "origin",
            "type": "boolean"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "_public",
            "baseName": "public",
            "type": "boolean"
        },
        {
            "name": "sla",
            "baseName": "sla",
            "type": "ServiceLevelAgreement"
        },
        {
            "name": "stepType",
            "baseName": "stepType",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        },
        {
            "name": "xpos",
            "baseName": "xpos",
            "type": "number"
        },
        {
            "name": "ypos",
            "baseName": "ypos",
            "type": "number"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Origin.attributeTypeMap);
    }
}

export class PageOfCurrentValue {
    'content'?: Array<CurrentValue>;
    'empty'?: boolean;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'size'?: number;
    'sort'?: Sort;
    'totalElements'?: number;
    'totalPages'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<CurrentValue>"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "numberOfElements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Sort"
        },
        {
            "name": "totalElements",
            "baseName": "totalElements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "totalPages",
            "type": "number"
        }];

    static getAttributeTypeMap() {
        return PageOfCurrentValue.attributeTypeMap;
    }
}

export class PageOfField {
    'content'?: Array<Field>;
    'empty'?: boolean;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'size'?: number;
    'sort'?: Sort;
    'totalElements'?: number;
    'totalPages'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<Field>"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "numberOfElements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Sort"
        },
        {
            "name": "totalElements",
            "baseName": "totalElements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "totalPages",
            "type": "number"
        }];

    static getAttributeTypeMap() {
        return PageOfField.attributeTypeMap;
    }
}

export class PageOfWorkflowResult {
    'content'?: Array<WorkflowResult>;
    'empty'?: boolean;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'size'?: number;
    'sort'?: Sort;
    'totalElements'?: number;
    'totalPages'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<WorkflowResult>"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "numberOfElements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Sort"
        },
        {
            "name": "totalElements",
            "baseName": "totalElements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "totalPages",
            "type": "number"
        }];

    static getAttributeTypeMap() {
        return PageOfWorkflowResult.attributeTypeMap;
    }
}

export class PendingAttachment extends CurrentValue {
    'active'?: boolean;
    'archived'?: boolean;
    'attachmentStatus'?: PendingAttachment.AttachmentStatusEnum;
    'awsS3Key'?: string;
    'contentType'?: string;
    'created'?: Date;
    '_default'?: boolean;
    'discriminator'?: string;
    'empty'?: boolean;
    'field'?: Field;
    'fieldId'?: string;
    'fileExtension'?: string;
    'fileSize'?: number;
    'hasValue'?: Field;
    'id'?: string;
    'isDefault'?: boolean;
    'labels'?: Array<string>;
    'numericValue'?: number;
    'originalFileExtension'?: string;
    'priority'?: number;
    'textValue'?: string;
    'updated'?: Date;
    'valueType'?: string;
    'versionCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "attachmentStatus",
            "baseName": "attachmentStatus",
            "type": "PendingAttachment.AttachmentStatusEnum"
        },
        {
            "name": "awsS3Key",
            "baseName": "awsS3Key",
            "type": "string"
        },
        {
            "name": "contentType",
            "baseName": "contentType",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "discriminator",
            "baseName": "discriminator",
            "type": "string"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        },
        {
            "name": "fileExtension",
            "baseName": "fileExtension",
            "type": "string"
        },
        {
            "name": "fileSize",
            "baseName": "fileSize",
            "type": "number"
        },
        {
            "name": "hasValue",
            "baseName": "hasValue",
            "type": "Field"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isDefault",
            "baseName": "isDefault",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "numericValue",
            "baseName": "numericValue",
            "type": "number"
        },
        {
            "name": "originalFileExtension",
            "baseName": "originalFileExtension",
            "type": "string"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "textValue",
            "baseName": "textValue",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        },
        {
            "name": "versionCount",
            "baseName": "versionCount",
            "type": "number"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PendingAttachment.attributeTypeMap);
    }
}

export namespace PendingAttachment {
    export enum AttachmentStatusEnum {
        PENDING = <any>'PENDING',
        CLEAN = <any>'CLEAN',
        DIRTY = <any>'DIRTY'
    }
}
/**
* An entity for managing top-level process data. A process represents the highest level of organization for other entities within the application.
*/
export class Process {
    'active'?: boolean;
    /**
    * Icon color of the process.
    */
    'color'?: string;
    'copied'?: boolean;
    'created'?: Date;
    /**
    * Icon type of the process.
    */
    'icon'?: Process.IconEnum;
    'id'?: string;
    'imported'?: boolean;
    'labels'?: Array<string>;
    /**
    * Name of the process.
    */
    'name'?: string;
    'updated'?: Date;
    /**
    * Workflows associated to the process.
    */
    'workflows'?: Array<Workflow>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "copied",
            "baseName": "copied",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "icon",
            "baseName": "icon",
            "type": "Process.IconEnum"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "imported",
            "baseName": "imported",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "workflows",
            "baseName": "workflows",
            "type": "Array<Workflow>"
        }];

    static getAttributeTypeMap() {
        return Process.attributeTypeMap;
    }
}

export namespace Process {
    export enum IconEnum {
        Bookmark = <any>'fa-bookmark',
        Bolt = <any>'fa-bolt',
        Bullhorn = <any>'fa-bullhorn',
        Certificate = <any>'fa-certificate',
        CheckSquareO = <any>'fa-check-square-o',
        Cloud = <any>'fa-cloud',
        Comments = <any>'fa-comments',
        Dollar = <any>'fa-dollar',
        ExclamationTriangle = <any>'fa-exclamation-triangle',
        FileTextO = <any>'fa-file-text-o',
        Folder = <any>'fa-folder',
        Gift = <any>'fa-gift',
        Globe = <any>'fa-globe',
        Heartbeat = <any>'fa-heartbeat',
        Leaf = <any>'fa-leaf',
        Legal = <any>'fa-legal',
        LifeRing = <any>'fa-life-ring',
        Medkit = <any>'fa-medkit',
        Money = <any>'fa-money',
        Percent = <any>'fa-percent',
        Rocket = <any>'fa-rocket',
        Signal = <any>'fa-signal',
        University = <any>'fa-university',
        UserCircle = <any>'fa-user-circle'
    }
}
export class Radio extends Field {
    'active'?: boolean;
    'convertibleTo'?: Array<string>;
    'created'?: Date;
    /**
    * Relationship to current values that are associated to the field.
    */
    'currentValues'?: Array<CurrentValue>;
    'discrete'?: boolean;
    'fieldType': Radio.FieldTypeEnum;
    'global'?: boolean;
    'id'?: string;
    /**
    * The label will appear as the label for the field when it appears on forms for user's to complete.
    */
    'label'?: string;
    'labels'?: Array<string>;
    /**
    * The name of the field.
    */
    'name'?: string;
    'operators'?: Array<Radio.OperatorsEnum>;
    /**
    * A text value that will populate any tooltip information.
    */
    'tooltip'?: string;
    'updated'?: Date;
    'valueType'?: string;
    /**
    * Workflow object that is associated to the field.
    */
    'workflow'?: Workflow;
    'workflowId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "convertibleTo",
            "baseName": "convertibleTo",
            "type": "Array<string>"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "currentValues",
            "baseName": "currentValues",
            "type": "Array<CurrentValue>"
        },
        {
            "name": "discrete",
            "baseName": "discrete",
            "type": "boolean"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "Radio.FieldTypeEnum"
        },
        {
            "name": "global",
            "baseName": "global",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "operators",
            "baseName": "operators",
            "type": "Array<Radio.OperatorsEnum>"
        },
        {
            "name": "tooltip",
            "baseName": "tooltip",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Radio.attributeTypeMap);
    }
}

export namespace Radio {
    export enum FieldTypeEnum {
        TEXT = <any>'TEXT',
        TEXTAREA = <any>'TEXT_AREA',
        DATEPICKER = <any>'DATE_PICKER',
        NUMBER = <any>'NUMBER',
        ESIGNATURE = <any>'E_SIGNATURE',
        CHECKBOX = <any>'CHECKBOX',
        MULTISELECT = <any>'MULTI_SELECT',
        RADIO = <any>'RADIO',
        SELECT = <any>'SELECT',
        USER = <any>'USER',
        ATTACHMENT = <any>'ATTACHMENT',
        CALCULATION = <any>'CALCULATION',
        DUEDATE = <any>'DUE_DATE'
    }
    export enum OperatorsEnum {
        EQUALS = <any>'EQUALS',
        NOTEQUALS = <any>'NOT_EQUALS',
        GREATERTHAN = <any>'GREATER_THAN',
        GREATERTHANEQUALS = <any>'GREATER_THAN_EQUALS',
        LESSTHAN = <any>'LESS_THAN',
        LESSTHANEQUALS = <any>'LESS_THAN_EQUALS',
        CONTAINS = <any>'CONTAINS',
        DOESNOTCONTAIN = <any>'DOES_NOT_CONTAIN',
        NULL = <any>'NULL',
        NOTNULL = <any>'NOT_NULL',
        MATCHES = <any>'MATCHES',
        DATERANGE = <any>'DATE_RANGE'
    }
}
export class Record {
    'active'?: boolean;
    'activeDate'?: Date;
    'assignee'?: User;
    'assignments'?: Array<Record>;
    'created'?: Date;
    'creator'?: User;
    'currentValueMaps'?: Array<ValueMap>;
    'dueDate'?: Date;
    'enteredNodeDate'?: Date;
    'enteredStepDate'?: Date;
    'id'?: string;
    'labels'?: Array<string>;
    'name'?: string;
    'node'?: Step;
    'nodeDueDate'?: Date;
    'origin'?: Step;
    '_public'?: boolean;
    'records'?: Array<Record>;
    'sequenceId'?: number;
    'status'?: Record.StatusEnum;
    'step'?: Step;
    'stepDueDate'?: Date;
    'updated'?: Date;
    'user'?: User;
    'userDate'?: Date;
    'userGroups'?: Array<UserGroup>;
    'workflow'?: Workflow;
    'workflowDueDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "activeDate",
            "baseName": "activeDate",
            "type": "Date"
        },
        {
            "name": "assignee",
            "baseName": "assignee",
            "type": "User"
        },
        {
            "name": "assignments",
            "baseName": "assignments",
            "type": "Array<Record>"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "creator",
            "baseName": "creator",
            "type": "User"
        },
        {
            "name": "currentValueMaps",
            "baseName": "currentValueMaps",
            "type": "Array<ValueMap>"
        },
        {
            "name": "dueDate",
            "baseName": "dueDate",
            "type": "Date"
        },
        {
            "name": "enteredNodeDate",
            "baseName": "enteredNodeDate",
            "type": "Date"
        },
        {
            "name": "enteredStepDate",
            "baseName": "enteredStepDate",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "node",
            "baseName": "node",
            "type": "Step"
        },
        {
            "name": "nodeDueDate",
            "baseName": "nodeDueDate",
            "type": "Date"
        },
        {
            "name": "origin",
            "baseName": "origin",
            "type": "Step"
        },
        {
            "name": "_public",
            "baseName": "public",
            "type": "boolean"
        },
        {
            "name": "records",
            "baseName": "records",
            "type": "Array<Record>"
        },
        {
            "name": "sequenceId",
            "baseName": "sequenceId",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Record.StatusEnum"
        },
        {
            "name": "step",
            "baseName": "step",
            "type": "Step"
        },
        {
            "name": "stepDueDate",
            "baseName": "stepDueDate",
            "type": "Date"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "userDate",
            "baseName": "userDate",
            "type": "Date"
        },
        {
            "name": "userGroups",
            "baseName": "userGroups",
            "type": "Array<UserGroup>"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowDueDate",
            "baseName": "workflowDueDate",
            "type": "Date"
        }];

    static getAttributeTypeMap() {
        return Record.attributeTypeMap;
    }
}

export namespace Record {
    export enum StatusEnum {
        INACTIVE = <any>'INACTIVE',
        NOTASSIGNED = <any>'NOT_ASSIGNED',
        ASSIGNED = <any>'ASSIGNED',
        INPROGRESS = <any>'IN_PROGRESS',
        COMPLETE = <any>'COMPLETE'
    }
}
export class RecordDetails {
    'canEdit'?: boolean;
    'canRead'?: boolean;
    'depth'?: number;
    'dueDate'?: Date;
    'id'?: string;
    'name'?: string;
    'step'?: Step;
    'stepEnd'?: boolean;
    'stepId'?: string;
    'user'?: boolean;
    'workflow'?: Workflow;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "canEdit",
            "baseName": "canEdit",
            "type": "boolean"
        },
        {
            "name": "canRead",
            "baseName": "canRead",
            "type": "boolean"
        },
        {
            "name": "depth",
            "baseName": "depth",
            "type": "number"
        },
        {
            "name": "dueDate",
            "baseName": "dueDate",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "step",
            "baseName": "step",
            "type": "Step"
        },
        {
            "name": "stepEnd",
            "baseName": "stepEnd",
            "type": "boolean"
        },
        {
            "name": "stepId",
            "baseName": "stepId",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "boolean"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        }];

    static getAttributeTypeMap() {
        return RecordDetails.attributeTypeMap;
    }
}

export class RecordProperty {
    'fieldType'?: RecordProperty.FieldTypeEnum;
    'formattedValue'?: string;
    'header'?: string;
    'rawValue'?: any;
    'systemField'?: RecordProperty.SystemFieldEnum;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "RecordProperty.FieldTypeEnum"
        },
        {
            "name": "formattedValue",
            "baseName": "formattedValue",
            "type": "string"
        },
        {
            "name": "header",
            "baseName": "header",
            "type": "string"
        },
        {
            "name": "rawValue",
            "baseName": "rawValue",
            "type": "any"
        },
        {
            "name": "systemField",
            "baseName": "systemField",
            "type": "RecordProperty.SystemFieldEnum"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return RecordProperty.attributeTypeMap;
    }
}

export namespace RecordProperty {
    export enum FieldTypeEnum {
        TEXT = <any>'TEXT',
        TEXTAREA = <any>'TEXT_AREA',
        DATEPICKER = <any>'DATE_PICKER',
        NUMBER = <any>'NUMBER',
        ESIGNATURE = <any>'E_SIGNATURE',
        CHECKBOX = <any>'CHECKBOX',
        MULTISELECT = <any>'MULTI_SELECT',
        RADIO = <any>'RADIO',
        SELECT = <any>'SELECT',
        USER = <any>'USER',
        ATTACHMENT = <any>'ATTACHMENT',
        CALCULATION = <any>'CALCULATION',
        DUEDATE = <any>'DUE_DATE'
    }
    export enum SystemFieldEnum {
        NAME = <any>'NAME',
        STATUS = <any>'STATUS',
        CREATED = <any>'CREATED',
        USERDATE = <any>'USER_DATE',
        EFFECTIVEDUEDATE = <any>'EFFECTIVE_DUE_DATE',
        DUEDATE = <any>'DUE_DATE',
        ID = <any>'ID',
        USERNAME = <any>'USER_NAME',
        USERID = <any>'USER_ID',
        CREATORNAME = <any>'CREATOR_NAME',
        USERGROUP = <any>'USER_GROUP',
        STEPNAME = <any>'STEP_NAME',
        STEPID = <any>'STEP_ID',
        ORIGINNAME = <any>'ORIGIN_NAME',
        WORKFLOWNAME = <any>'WORKFLOW_NAME',
        WORKFLOWRECORDPREFIX = <any>'WORKFLOW_RECORD_PREFIX',
        WORKFLOWID = <any>'WORKFLOW_ID'
    }
}
export class ReportFilter {
    'active'?: boolean;
    'created'?: Date;
    'field'?: Field;
    'filteredRelativeIds'?: Array<string>;
    'filteredRelatives'?: Array<GraphEntity>;
    'fixed'?: boolean;
    'id'?: string;
    'labels'?: Array<string>;
    'operator'?: ReportFilter.OperatorEnum;
    'recordRelationship'?: ReportFilter.RecordRelationshipEnum;
    'systemField'?: ReportFilter.SystemFieldEnum;
    'updated'?: Date;
    'valid'?: boolean;
    'values'?: Array<CurrentValue>;
    'workflow'?: Workflow;
    'workflowId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "filteredRelativeIds",
            "baseName": "filteredRelativeIds",
            "type": "Array<string>"
        },
        {
            "name": "filteredRelatives",
            "baseName": "filteredRelatives",
            "type": "Array<GraphEntity>"
        },
        {
            "name": "fixed",
            "baseName": "fixed",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "operator",
            "baseName": "operator",
            "type": "ReportFilter.OperatorEnum"
        },
        {
            "name": "recordRelationship",
            "baseName": "recordRelationship",
            "type": "ReportFilter.RecordRelationshipEnum"
        },
        {
            "name": "systemField",
            "baseName": "systemField",
            "type": "ReportFilter.SystemFieldEnum"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valid",
            "baseName": "valid",
            "type": "boolean"
        },
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<CurrentValue>"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return ReportFilter.attributeTypeMap;
    }
}

export namespace ReportFilter {
    export enum OperatorEnum {
        EQUALS = <any>'EQUALS',
        NOTEQUALS = <any>'NOT_EQUALS',
        GREATERTHAN = <any>'GREATER_THAN',
        GREATERTHANEQUALS = <any>'GREATER_THAN_EQUALS',
        LESSTHAN = <any>'LESS_THAN',
        LESSTHANEQUALS = <any>'LESS_THAN_EQUALS',
        CONTAINS = <any>'CONTAINS',
        DOESNOTCONTAIN = <any>'DOES_NOT_CONTAIN',
        NULL = <any>'NULL',
        NOTNULL = <any>'NOT_NULL',
        MATCHES = <any>'MATCHES',
        DATERANGE = <any>'DATE_RANGE'
    }
    export enum RecordRelationshipEnum {
        CURRENTSTEP = <any>'CURRENT_STEP',
        ORIGINSTEP = <any>'ORIGIN_STEP'
    }
    export enum SystemFieldEnum {
        NAME = <any>'NAME',
        STATUS = <any>'STATUS',
        CREATED = <any>'CREATED',
        USERDATE = <any>'USER_DATE',
        EFFECTIVEDUEDATE = <any>'EFFECTIVE_DUE_DATE',
        DUEDATE = <any>'DUE_DATE',
        ID = <any>'ID',
        USERNAME = <any>'USER_NAME',
        USERID = <any>'USER_ID',
        CREATORNAME = <any>'CREATOR_NAME',
        USERGROUP = <any>'USER_GROUP',
        STEPNAME = <any>'STEP_NAME',
        STEPID = <any>'STEP_ID',
        ORIGINNAME = <any>'ORIGIN_NAME',
        WORKFLOWNAME = <any>'WORKFLOW_NAME',
        WORKFLOWRECORDPREFIX = <any>'WORKFLOW_RECORD_PREFIX',
        WORKFLOWID = <any>'WORKFLOW_ID'
    }
}
export class Repository extends Layout {
    'active'?: boolean;
    'created'?: Date;
    'defaultLayout'?: boolean;
    'id'?: string;
    'labels'?: Array<string>;
    'layoutFields'?: Array<LayoutField>;
    'title'?: string;
    'updated'?: Date;
    'workflow'?: Workflow;
    'workflowId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "defaultLayout",
            "baseName": "defaultLayout",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "layoutFields",
            "baseName": "layoutFields",
            "type": "Array<LayoutField>"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Repository.attributeTypeMap);
    }
}

export class Resource {
    'description'?: string;
    'file'?: any;
    'filename'?: string;
    'inputStream'?: InputStream;
    'open'?: boolean;
    'readable'?: boolean;
    'uri'?: URI;
    'url'?: URL;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "file",
            "baseName": "file",
            "type": "any"
        },
        {
            "name": "filename",
            "baseName": "filename",
            "type": "string"
        },
        {
            "name": "inputStream",
            "baseName": "inputStream",
            "type": "InputStream"
        },
        {
            "name": "open",
            "baseName": "open",
            "type": "boolean"
        },
        {
            "name": "readable",
            "baseName": "readable",
            "type": "boolean"
        },
        {
            "name": "uri",
            "baseName": "uri",
            "type": "URI"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "URL"
        }];

    static getAttributeTypeMap() {
        return Resource.attributeTypeMap;
    }
}

export class Role {
    'active'?: boolean;
    'created'?: Date;
    'id'?: string;
    'labels'?: Array<string>;
    'locked'?: boolean;
    'moduleCount'?: number;
    'moduleEntitlements'?: Array<ModuleEntitlement>;
    'name'?: string;
    'nodeEntitlements'?: Array<StepEntitlement>;
    'stepCount'?: number;
    'stepEntitlements'?: Array<StepEntitlement>;
    'updated'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "locked",
            "baseName": "locked",
            "type": "boolean"
        },
        {
            "name": "moduleCount",
            "baseName": "moduleCount",
            "type": "number"
        },
        {
            "name": "moduleEntitlements",
            "baseName": "moduleEntitlements",
            "type": "Array<ModuleEntitlement>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "nodeEntitlements",
            "baseName": "nodeEntitlements",
            "type": "Array<StepEntitlement>"
        },
        {
            "name": "stepCount",
            "baseName": "stepCount",
            "type": "number"
        },
        {
            "name": "stepEntitlements",
            "baseName": "stepEntitlements",
            "type": "Array<StepEntitlement>"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }];

    static getAttributeTypeMap() {
        return Role.attributeTypeMap;
    }
}

export class Select extends Field {
    'active'?: boolean;
    'convertibleTo'?: Array<string>;
    'created'?: Date;
    /**
    * Relationship to current values that are associated to the field.
    */
    'currentValues'?: Array<CurrentValue>;
    'discrete'?: boolean;
    'fieldType': Select.FieldTypeEnum;
    'global'?: boolean;
    'id'?: string;
    /**
    * The label will appear as the label for the field when it appears on forms for user's to complete.
    */
    'label'?: string;
    'labels'?: Array<string>;
    /**
    * The name of the field.
    */
    'name'?: string;
    'operators'?: Array<Select.OperatorsEnum>;
    /**
    * A text value that will populate any tooltip information.
    */
    'tooltip'?: string;
    'updated'?: Date;
    'valueType'?: string;
    /**
    * Workflow object that is associated to the field.
    */
    'workflow'?: Workflow;
    'workflowId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "convertibleTo",
            "baseName": "convertibleTo",
            "type": "Array<string>"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "currentValues",
            "baseName": "currentValues",
            "type": "Array<CurrentValue>"
        },
        {
            "name": "discrete",
            "baseName": "discrete",
            "type": "boolean"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "Select.FieldTypeEnum"
        },
        {
            "name": "global",
            "baseName": "global",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "operators",
            "baseName": "operators",
            "type": "Array<Select.OperatorsEnum>"
        },
        {
            "name": "tooltip",
            "baseName": "tooltip",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Select.attributeTypeMap);
    }
}

export namespace Select {
    export enum FieldTypeEnum {
        TEXT = <any>'TEXT',
        TEXTAREA = <any>'TEXT_AREA',
        DATEPICKER = <any>'DATE_PICKER',
        NUMBER = <any>'NUMBER',
        ESIGNATURE = <any>'E_SIGNATURE',
        CHECKBOX = <any>'CHECKBOX',
        MULTISELECT = <any>'MULTI_SELECT',
        RADIO = <any>'RADIO',
        SELECT = <any>'SELECT',
        USER = <any>'USER',
        ATTACHMENT = <any>'ATTACHMENT',
        CALCULATION = <any>'CALCULATION',
        DUEDATE = <any>'DUE_DATE'
    }
    export enum OperatorsEnum {
        EQUALS = <any>'EQUALS',
        NOTEQUALS = <any>'NOT_EQUALS',
        GREATERTHAN = <any>'GREATER_THAN',
        GREATERTHANEQUALS = <any>'GREATER_THAN_EQUALS',
        LESSTHAN = <any>'LESS_THAN',
        LESSTHANEQUALS = <any>'LESS_THAN_EQUALS',
        CONTAINS = <any>'CONTAINS',
        DOESNOTCONTAIN = <any>'DOES_NOT_CONTAIN',
        NULL = <any>'NULL',
        NOTNULL = <any>'NOT_NULL',
        MATCHES = <any>'MATCHES',
        DATERANGE = <any>'DATE_RANGE'
    }
}
export class ServiceLevelAgreement {
    'duration'?: number;
    'enabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        }];

    static getAttributeTypeMap() {
        return ServiceLevelAgreement.attributeTypeMap;
    }
}

export class Sort {
    'empty'?: boolean;
    'sorted'?: boolean;
    'unsorted'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        },
        {
            "name": "sorted",
            "baseName": "sorted",
            "type": "boolean"
        },
        {
            "name": "unsorted",
            "baseName": "unsorted",
            "type": "boolean"
        }];

    static getAttributeTypeMap() {
        return Sort.attributeTypeMap;
    }
}



export class StepEntitlement {
    'active'?: boolean;
    'created'?: Date;
    'id'?: string;
    'labels'?: Array<string>;
    'node'?: Step;
    'operationType'?: string;
    'role'?: Role;
    'step'?: Step;
    'updated'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "node",
            "baseName": "node",
            "type": "Step"
        },
        {
            "name": "operationType",
            "baseName": "operationType",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "Role"
        },
        {
            "name": "step",
            "baseName": "step",
            "type": "Step"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }];

    static getAttributeTypeMap() {
        return StepEntitlement.attributeTypeMap;
    }
}

export class TableReport extends Layout {
    'active'?: boolean;
    'created'?: Date;
    'defaultLayout'?: boolean;
    'filterList'?: Array<ReportFilter>;
    'id'?: string;
    'labels'?: Array<string>;
    'layoutFields'?: Array<LayoutField>;
    'title'?: string;
    'updated'?: Date;
    'workflow'?: Workflow;
    'workflowId'?: string;
    'workflowJoins'?: Array<TableReportJoin>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "defaultLayout",
            "baseName": "defaultLayout",
            "type": "boolean"
        },
        {
            "name": "filterList",
            "baseName": "filterList",
            "type": "Array<ReportFilter>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "layoutFields",
            "baseName": "layoutFields",
            "type": "Array<LayoutField>"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        },
        {
            "name": "workflowJoins",
            "baseName": "workflowJoins",
            "type": "Array<TableReportJoin>"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TableReport.attributeTypeMap);
    }
}

export class TableReportJoin {
    'active'?: boolean;
    'childrenJoins'?: Array<TableReportJoin>;
    'comesFrom'?: TableReportJoin;
    'comesFromId'?: string;
    'created'?: Date;
    'distinct'?: boolean;
    'id'?: string;
    'isDistinct'?: boolean;
    'joinedThrough'?: WorkflowMap;
    'joinedWorkflow'?: Workflow;
    'labels'?: Array<string>;
    'updated'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "childrenJoins",
            "baseName": "childrenJoins",
            "type": "Array<TableReportJoin>"
        },
        {
            "name": "comesFrom",
            "baseName": "comesFrom",
            "type": "TableReportJoin"
        },
        {
            "name": "comesFromId",
            "baseName": "comesFromId",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "distinct",
            "baseName": "distinct",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isDistinct",
            "baseName": "isDistinct",
            "type": "boolean"
        },
        {
            "name": "joinedThrough",
            "baseName": "joinedThrough",
            "type": "WorkflowMap"
        },
        {
            "name": "joinedWorkflow",
            "baseName": "joinedWorkflow",
            "type": "Workflow"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }];

    static getAttributeTypeMap() {
        return TableReportJoin.attributeTypeMap;
    }
}

export class Text extends Field {
    'active'?: boolean;
    'convertibleTo'?: Array<string>;
    'created'?: Date;
    /**
    * Relationship to current values that are associated to the field.
    */
    'currentValues'?: Array<CurrentValue>;
    'discrete'?: boolean;
    'fieldType': Text.FieldTypeEnum;
    'global'?: boolean;
    'id'?: string;
    /**
    * The label will appear as the label for the field when it appears on forms for user's to complete.
    */
    'label'?: string;
    'labels'?: Array<string>;
    'message'?: string;
    /**
    * The name of the field.
    */
    'name'?: string;
    'operators'?: Array<Text.OperatorsEnum>;
    'pattern'?: string;
    /**
    * A text value that will populate any tooltip information.
    */
    'tooltip'?: string;
    'updated'?: Date;
    'valueType'?: string;
    /**
    * Workflow object that is associated to the field.
    */
    'workflow'?: Workflow;
    'workflowId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "convertibleTo",
            "baseName": "convertibleTo",
            "type": "Array<string>"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "currentValues",
            "baseName": "currentValues",
            "type": "Array<CurrentValue>"
        },
        {
            "name": "discrete",
            "baseName": "discrete",
            "type": "boolean"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "Text.FieldTypeEnum"
        },
        {
            "name": "global",
            "baseName": "global",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "operators",
            "baseName": "operators",
            "type": "Array<Text.OperatorsEnum>"
        },
        {
            "name": "pattern",
            "baseName": "pattern",
            "type": "string"
        },
        {
            "name": "tooltip",
            "baseName": "tooltip",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Text.attributeTypeMap);
    }
}

export namespace Text {
    export enum FieldTypeEnum {
        TEXT = <any>'TEXT',
        TEXTAREA = <any>'TEXT_AREA',
        DATEPICKER = <any>'DATE_PICKER',
        NUMBER = <any>'NUMBER',
        ESIGNATURE = <any>'E_SIGNATURE',
        CHECKBOX = <any>'CHECKBOX',
        MULTISELECT = <any>'MULTI_SELECT',
        RADIO = <any>'RADIO',
        SELECT = <any>'SELECT',
        USER = <any>'USER',
        ATTACHMENT = <any>'ATTACHMENT',
        CALCULATION = <any>'CALCULATION',
        DUEDATE = <any>'DUE_DATE'
    }
    export enum OperatorsEnum {
        EQUALS = <any>'EQUALS',
        NOTEQUALS = <any>'NOT_EQUALS',
        GREATERTHAN = <any>'GREATER_THAN',
        GREATERTHANEQUALS = <any>'GREATER_THAN_EQUALS',
        LESSTHAN = <any>'LESS_THAN',
        LESSTHANEQUALS = <any>'LESS_THAN_EQUALS',
        CONTAINS = <any>'CONTAINS',
        DOESNOTCONTAIN = <any>'DOES_NOT_CONTAIN',
        NULL = <any>'NULL',
        NOTNULL = <any>'NOT_NULL',
        MATCHES = <any>'MATCHES',
        DATERANGE = <any>'DATE_RANGE'
    }
}
export class TextArea extends Field {
    'active'?: boolean;
    'convertibleTo'?: Array<string>;
    'created'?: Date;
    /**
    * Relationship to current values that are associated to the field.
    */
    'currentValues'?: Array<CurrentValue>;
    'discrete'?: boolean;
    'fieldType': TextArea.FieldTypeEnum;
    'global'?: boolean;
    'hasHtml'?: boolean;
    'id'?: string;
    /**
    * The label will appear as the label for the field when it appears on forms for user's to complete.
    */
    'label'?: string;
    'labels'?: Array<string>;
    'message'?: string;
    /**
    * The name of the field.
    */
    'name'?: string;
    'operators'?: Array<TextArea.OperatorsEnum>;
    'pattern'?: string;
    /**
    * A text value that will populate any tooltip information.
    */
    'tooltip'?: string;
    'updated'?: Date;
    'valueType'?: string;
    /**
    * Workflow object that is associated to the field.
    */
    'workflow'?: Workflow;
    'workflowId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "convertibleTo",
            "baseName": "convertibleTo",
            "type": "Array<string>"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "currentValues",
            "baseName": "currentValues",
            "type": "Array<CurrentValue>"
        },
        {
            "name": "discrete",
            "baseName": "discrete",
            "type": "boolean"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "TextArea.FieldTypeEnum"
        },
        {
            "name": "global",
            "baseName": "global",
            "type": "boolean"
        },
        {
            "name": "hasHtml",
            "baseName": "hasHtml",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "operators",
            "baseName": "operators",
            "type": "Array<TextArea.OperatorsEnum>"
        },
        {
            "name": "pattern",
            "baseName": "pattern",
            "type": "string"
        },
        {
            "name": "tooltip",
            "baseName": "tooltip",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "valueType",
            "baseName": "valueType",
            "type": "string"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "Workflow"
        },
        {
            "name": "workflowId",
            "baseName": "workflowId",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextArea.attributeTypeMap);
    }
}

export namespace TextArea {
    export enum FieldTypeEnum {
        TEXT = <any>'TEXT',
        TEXTAREA = <any>'TEXT_AREA',
        DATEPICKER = <any>'DATE_PICKER',
        NUMBER = <any>'NUMBER',
        ESIGNATURE = <any>'E_SIGNATURE',
        CHECKBOX = <any>'CHECKBOX',
        MULTISELECT = <any>'MULTI_SELECT',
        RADIO = <any>'RADIO',
        SELECT = <any>'SELECT',
        USER = <any>'USER',
        ATTACHMENT = <any>'ATTACHMENT',
        CALCULATION = <any>'CALCULATION',
        DUEDATE = <any>'DUE_DATE'
    }
    export enum OperatorsEnum {
        EQUALS = <any>'EQUALS',
        NOTEQUALS = <any>'NOT_EQUALS',
        GREATERTHAN = <any>'GREATER_THAN',
        GREATERTHANEQUALS = <any>'GREATER_THAN_EQUALS',
        LESSTHAN = <any>'LESS_THAN',
        LESSTHANEQUALS = <any>'LESS_THAN_EQUALS',
        CONTAINS = <any>'CONTAINS',
        DOESNOTCONTAIN = <any>'DOES_NOT_CONTAIN',
        NULL = <any>'NULL',
        NOTNULL = <any>'NOT_NULL',
        MATCHES = <any>'MATCHES',
        DATERANGE = <any>'DATE_RANGE'
    }
}
export class URI {
    'absolute'?: boolean;
    'authority'?: string;
    'fragment'?: string;
    'host'?: string;
    'opaque'?: boolean;
    'path'?: string;
    'port'?: number;
    'query'?: string;
    'rawAuthority'?: string;
    'rawFragment'?: string;
    'rawPath'?: string;
    'rawQuery'?: string;
    'rawSchemeSpecificPart'?: string;
    'rawUserInfo'?: string;
    'scheme'?: string;
    'schemeSpecificPart'?: string;
    'userInfo'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "absolute",
            "baseName": "absolute",
            "type": "boolean"
        },
        {
            "name": "authority",
            "baseName": "authority",
            "type": "string"
        },
        {
            "name": "fragment",
            "baseName": "fragment",
            "type": "string"
        },
        {
            "name": "host",
            "baseName": "host",
            "type": "string"
        },
        {
            "name": "opaque",
            "baseName": "opaque",
            "type": "boolean"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "port",
            "baseName": "port",
            "type": "number"
        },
        {
            "name": "query",
            "baseName": "query",
            "type": "string"
        },
        {
            "name": "rawAuthority",
            "baseName": "rawAuthority",
            "type": "string"
        },
        {
            "name": "rawFragment",
            "baseName": "rawFragment",
            "type": "string"
        },
        {
            "name": "rawPath",
            "baseName": "rawPath",
            "type": "string"
        },
        {
            "name": "rawQuery",
            "baseName": "rawQuery",
            "type": "string"
        },
        {
            "name": "rawSchemeSpecificPart",
            "baseName": "rawSchemeSpecificPart",
            "type": "string"
        },
        {
            "name": "rawUserInfo",
            "baseName": "rawUserInfo",
            "type": "string"
        },
        {
            "name": "scheme",
            "baseName": "scheme",
            "type": "string"
        },
        {
            "name": "schemeSpecificPart",
            "baseName": "schemeSpecificPart",
            "type": "string"
        },
        {
            "name": "userInfo",
            "baseName": "userInfo",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return URI.attributeTypeMap;
    }
}

export class URL {
    'authority'?: string;
    'content'?: any;
    'defaultPort'?: number;
    'deserializedFields'?: URLStreamHandler;
    'file'?: string;
    'host'?: string;
    'path'?: string;
    'port'?: number;
    'protocol'?: string;
    'query'?: string;
    'ref'?: string;
    'serializedHashCode'?: number;
    'userInfo'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "authority",
            "baseName": "authority",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "any"
        },
        {
            "name": "defaultPort",
            "baseName": "defaultPort",
            "type": "number"
        },
        {
            "name": "deserializedFields",
            "baseName": "deserializedFields",
            "type": "URLStreamHandler"
        },
        {
            "name": "file",
            "baseName": "file",
            "type": "string"
        },
        {
            "name": "host",
            "baseName": "host",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "port",
            "baseName": "port",
            "type": "number"
        },
        {
            "name": "protocol",
            "baseName": "protocol",
            "type": "string"
        },
        {
            "name": "query",
            "baseName": "query",
            "type": "string"
        },
        {
            "name": "ref",
            "baseName": "ref",
            "type": "string"
        },
        {
            "name": "serializedHashCode",
            "baseName": "serializedHashCode",
            "type": "number"
        },
        {
            "name": "userInfo",
            "baseName": "userInfo",
            "type": "string"
        }];

    static getAttributeTypeMap() {
        return URL.attributeTypeMap;
    }
}

export class URLStreamHandler {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    ];

    static getAttributeTypeMap() {
        return URLStreamHandler.attributeTypeMap;
    }
}



export namespace User {
    export enum TierEnum {
        PRIMARY = <any>'PRIMARY',
        SECONDARY = <any>'SECONDARY',
        LIMITED = <any>'LIMITED'
    }
}
export class UserGroup {
    'active'?: boolean;
    'assignmentDefault'?: boolean;
    'created'?: Date;
    'id'?: string;
    'labels'?: Array<string>;
    'recordDefault'?: boolean;
    'title'?: string;
    'updated'?: Date;
    'users'?: Array<User>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "assignmentDefault",
            "baseName": "assignmentDefault",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "recordDefault",
            "baseName": "recordDefault",
            "type": "boolean"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "users",
            "baseName": "users",
            "type": "Array<User>"
        }];

    static getAttributeTypeMap() {
        return UserGroup.attributeTypeMap;
    }
}

export class ValueMap {
    'active'?: boolean;
    'assignment'?: Record;
    'created'?: Date;
    'currentValues'?: Array<CurrentValue>;
    'expressionResult'?: number;
    'field'?: Field;
    'id'?: string;
    'labels'?: Array<string>;
    'node'?: Step;
    'record'?: Record;
    'step'?: Step;
    'updated'?: Date;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "assignment",
            "baseName": "assignment",
            "type": "Record"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "currentValues",
            "baseName": "currentValues",
            "type": "Array<CurrentValue>"
        },
        {
            "name": "expressionResult",
            "baseName": "expressionResult",
            "type": "number"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "node",
            "baseName": "node",
            "type": "Step"
        },
        {
            "name": "record",
            "baseName": "record",
            "type": "Record"
        },
        {
            "name": "step",
            "baseName": "step",
            "type": "Step"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }];

    static getAttributeTypeMap() {
        return ValueMap.attributeTypeMap;
    }
}

/**
* An entity that contains information about a set of steps within a particular process.
*/
export class Workflow {
    'active'?: boolean;
    /**
    * Nodes created in the workflow are allowed user groups.
    */
    'allowGroups'?: boolean;
    'canSelect'?: Field;
    'contains'?: Step;
    'created'?: Date;
    'fields'?: Array<Field>;
    'id'?: string;
    'labels'?: Array<string>;
    /**
    * Name of the workflow.
    */
    'name'?: string;
    'nodes'?: Array<Step>;
    'objectName'?: string;
    /**
    * Determines the workflow's place in the process.
    */
    'priority'?: number;
    /**
    * Process that the workflow belongs to.
    */
    'process'?: Process;
    'processId'?: string;
    /**
    * Name to be used for every record created from the workflow.
    */
    'recordPrefix'?: string;
    /**
    * Nodes created in the workflow require user groups.
    */
    'requireGroups'?: boolean;
    'sequence'?: WorkflowSequence;
    /**
    * Object containing all SLA information.
    */
    'sla'?: ServiceLevelAgreement;
    /**
    * List of nodes that the workflow contains.
    */
    'steps'?: Array<Step>;
    'updated'?: Date;
    /**
    * User groups that are allowed access to the workflow
    */
    'userGroups'?: Array<UserGroup>;
    'workflowMaps'?: Array<WorkflowMap>;
    /**
    * X axis position of the workflow on the process screen
    */
    'xpos'?: number;
    /**
    * Y axis position of the workflow on the process screen
    */
    'ypos'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "allowGroups",
            "baseName": "allowGroups",
            "type": "boolean"
        },
        {
            "name": "canSelect",
            "baseName": "canSelect",
            "type": "Field"
        },
        {
            "name": "contains",
            "baseName": "contains",
            "type": "Step"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "fields",
            "baseName": "fields",
            "type": "Array<Field>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "nodes",
            "baseName": "nodes",
            "type": "Array<Step>"
        },
        {
            "name": "objectName",
            "baseName": "objectName",
            "type": "string"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "process",
            "baseName": "process",
            "type": "Process"
        },
        {
            "name": "processId",
            "baseName": "processId",
            "type": "string"
        },
        {
            "name": "recordPrefix",
            "baseName": "recordPrefix",
            "type": "string"
        },
        {
            "name": "requireGroups",
            "baseName": "requireGroups",
            "type": "boolean"
        },
        {
            "name": "sequence",
            "baseName": "sequence",
            "type": "WorkflowSequence"
        },
        {
            "name": "sla",
            "baseName": "sla",
            "type": "ServiceLevelAgreement"
        },
        {
            "name": "steps",
            "baseName": "steps",
            "type": "Array<Step>"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "userGroups",
            "baseName": "userGroups",
            "type": "Array<UserGroup>"
        },
        {
            "name": "workflowMaps",
            "baseName": "workflowMaps",
            "type": "Array<WorkflowMap>"
        },
        {
            "name": "xpos",
            "baseName": "xpos",
            "type": "number"
        },
        {
            "name": "ypos",
            "baseName": "ypos",
            "type": "number"
        }];

    static getAttributeTypeMap() {
        return Workflow.attributeTypeMap;
    }
}



export class WorkflowResult {
    'assignments'?: number;
    'assignmentsComplete'?: number;
    'assignmentsOverdue'?: number;
    'depth'?: number;
    'id'?: string;
    'name'?: string;
    'process'?: Process;
    'recordPrefix'?: string;
    'records'?: number;
    'recordsComplete'?: number;
    'recordsOverdue'?: number;
    'steps'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "assignments",
            "baseName": "assignments",
            "type": "number"
        },
        {
            "name": "assignmentsComplete",
            "baseName": "assignmentsComplete",
            "type": "number"
        },
        {
            "name": "assignmentsOverdue",
            "baseName": "assignmentsOverdue",
            "type": "number"
        },
        {
            "name": "depth",
            "baseName": "depth",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "process",
            "baseName": "process",
            "type": "Process"
        },
        {
            "name": "recordPrefix",
            "baseName": "recordPrefix",
            "type": "string"
        },
        {
            "name": "records",
            "baseName": "records",
            "type": "number"
        },
        {
            "name": "recordsComplete",
            "baseName": "recordsComplete",
            "type": "number"
        },
        {
            "name": "recordsOverdue",
            "baseName": "recordsOverdue",
            "type": "number"
        },
        {
            "name": "steps",
            "baseName": "steps",
            "type": "number"
        }];

    static getAttributeTypeMap() {
        return WorkflowResult.attributeTypeMap;
    }
}

export class WorkflowSequence {
    'active'?: boolean;
    'created'?: Date;
    'format'?: string;
    'id'?: string;
    'incrementBy'?: number;
    'labels'?: Array<string>;
    'updated'?: Date;
    'value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "format",
            "baseName": "format",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "incrementBy",
            "baseName": "incrementBy",
            "type": "number"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }];

    static getAttributeTypeMap() {
        return WorkflowSequence.attributeTypeMap;
    }
}


let enumsMap: { [index: string]: any } = {
    "Active.TierEnum": Active.TierEnum,
    "Attachment.FieldTypeEnum": Attachment.FieldTypeEnum,
    "Attachment.OperatorsEnum": Attachment.OperatorsEnum,
    "Calculation.FieldTypeEnum": Calculation.FieldTypeEnum,
    "Calculation.LogicalHandlingEnum": Calculation.LogicalHandlingEnum,
    "Calculation.NullStrategyEnum": Calculation.NullStrategyEnum,
    "Calculation.OperatorsEnum": Calculation.OperatorsEnum,
    "Checkbox.FieldTypeEnum": Checkbox.FieldTypeEnum,
    "Checkbox.OperatorsEnum": Checkbox.OperatorsEnum,
    "CleanAttachment.AttachmentStatusEnum": CleanAttachment.AttachmentStatusEnum,
    "DatePicker.FieldTypeEnum": DatePicker.FieldTypeEnum,
    "DatePicker.OperatorsEnum": DatePicker.OperatorsEnum,
    "DirtyAttachment.AttachmentStatusEnum": DirtyAttachment.AttachmentStatusEnum,
    "Disabled.TierEnum": Disabled.TierEnum,
    "DueDate.FieldTypeEnum": DueDate.FieldTypeEnum,
    "DueDate.OperatorsEnum": DueDate.OperatorsEnum,
    "ESignature.FieldTypeEnum": ESignature.FieldTypeEnum,
    "ESignature.OperatorsEnum": ESignature.OperatorsEnum,
    "External.TierEnum": External.TierEnum,
    "Field.FieldTypeEnum": Field.FieldTypeEnum,
    "Field.OperatorsEnum": Field.OperatorsEnum,
    "LayoutField.CategoryEnum": LayoutField.CategoryEnum,
    "LayoutField.DirectionEnum": LayoutField.DirectionEnum,
    "LayoutField.LabelDisplayTypeEnum": LayoutField.LabelDisplayTypeEnum,
    "LayoutField.OperatorsEnum": LayoutField.OperatorsEnum,
    "LayoutField.SystemFieldEnum": LayoutField.SystemFieldEnum,
    "Locked.TierEnum": Locked.TierEnum,
    "Module.ValueEnum": Module.ValueEnum,
    "MultiSelect.FieldTypeEnum": MultiSelect.FieldTypeEnum,
    "MultiSelect.OperatorsEnum": MultiSelect.OperatorsEnum,
    "Number.FieldTypeEnum": Number.FieldTypeEnum,
    "Number.OperatorsEnum": Number.OperatorsEnum,
    "PendingAttachment.AttachmentStatusEnum": PendingAttachment.AttachmentStatusEnum,
    "Process.IconEnum": Process.IconEnum,
    "Radio.FieldTypeEnum": Radio.FieldTypeEnum,
    "Radio.OperatorsEnum": Radio.OperatorsEnum,
    "Record.StatusEnum": Record.StatusEnum,
    "RecordProperty.FieldTypeEnum": RecordProperty.FieldTypeEnum,
    "RecordProperty.SystemFieldEnum": RecordProperty.SystemFieldEnum,
    "ReportFilter.OperatorEnum": ReportFilter.OperatorEnum,
    "ReportFilter.RecordRelationshipEnum": ReportFilter.RecordRelationshipEnum,
    "ReportFilter.SystemFieldEnum": ReportFilter.SystemFieldEnum,
    "Select.FieldTypeEnum": Select.FieldTypeEnum,
    "Select.OperatorsEnum": Select.OperatorsEnum,
    "Text.FieldTypeEnum": Text.FieldTypeEnum,
    "Text.OperatorsEnum": Text.OperatorsEnum,
    "TextArea.FieldTypeEnum": TextArea.FieldTypeEnum,
    "TextArea.OperatorsEnum": TextArea.OperatorsEnum,
    "User.TierEnum": User.TierEnum,
}

let typeMap: { [index: string]: any } = {
    "AccessAudit": AccessAudit,
    "Active": Active,
    "Attachment": Attachment,
    "Calculation": Calculation,
    "Chain": Chain,
    "Checkbox": Checkbox,
    "ChildResult": ChildResult,
    "CleanAttachment": CleanAttachment,
    "CurrentCommonValue": CurrentCommonValue,
    "CurrentDateRangeValue": CurrentDateRangeValue,
    "CurrentDateValue": CurrentDateValue,
    "CurrentValue": CurrentValue,
    "DatePicker": DatePicker,
    "DirtyAttachment": DirtyAttachment,
    "Disabled": Disabled,
    "Display": Display,
    "DueDate": DueDate,
    "ESignature": ESignature,
    "End": End,
    "External": External,
    "Field": Field,
    "FieldInput": FieldInput,
    "FieldInputResult": FieldInputResult,
    "FilteredRecord": FilteredRecord,
    "GraphEntity": GraphEntity,
    "ImportRecordRequest": ImportRecordRequest,
    "ImportRequest": ImportRequest,
    "ImportUserRequest": ImportUserRequest,
    "InputStream": InputStream,
    "LabelValue": LabelValue,
    "Layout": Layout,
    "LayoutField": LayoutField,
    "Locked": Locked,
    "LogIn": LogIn,
    "LogInFail": LogInFail,
    "LogOut": LogOut,
    "ManyToMany": ManyToMany,
    "ManyToOne": ManyToOne,
    "ModelDefault": ModelDefault,
    "ModelFile": ModelFile,
    "Module": Module,
    "ModuleEntitlement": ModuleEntitlement,
    "MultiSelect": MultiSelect,
    "Number": Number,
    "OneToMany": OneToMany,
    "OneToOne": OneToOne,
    "Origin": Origin,
    "PageOfCurrentValue": PageOfCurrentValue,
    "PageOfField": PageOfField,
    "PageOfWorkflowResult": PageOfWorkflowResult,
    "PendingAttachment": PendingAttachment,
    "Process": Process,
    "Radio": Radio,
    "Record": Record,
    "RecordDetails": RecordDetails,
    "RecordProperty": RecordProperty,
    "ReportFilter": ReportFilter,
    "Repository": Repository,
    "Resource": Resource,
    "Role": Role,
    "Select": Select,
    "ServiceLevelAgreement": ServiceLevelAgreement,
    "Sort": Sort,
    "Step": Step,
    "StepEntitlement": StepEntitlement,
    "TableReport": TableReport,
    "TableReportJoin": TableReportJoin,
    "Text": Text,
    "TextArea": TextArea,
    "URI": URI,
    "URL": URL,
    "URLStreamHandler": URLStreamHandler,
    "User": User,
    "UserGroup": UserGroup,
    "ValueMap": ValueMap,
    "Workflow": Workflow,
    "WorkflowMap": WorkflowMap,
    "WorkflowResult": WorkflowResult,
    "WorkflowSequence": WorkflowSequence,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum CurrentValuesApiApiKeys {
    Bearer,
}

export class CurrentValuesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: CurrentValuesApiApiKeys, value: string) {
        (this.authentications as any)[CurrentValuesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a list of current values for a specified field.
     * @param currentValues currentValues
     * @param field field
     * @param {*} [options] Override http request options.
     */
    public createUsingPOST(currentValues: Array<CurrentValue>, field: string, options: any = {}): Promise<{ response: ClientResponse; body: Array<CurrentValue>; }> {
        const localVarPath = this.basePath + '/api/v1/currentValues';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'currentValues' is not null or undefined
        if (currentValues === null || currentValues === undefined) {
            throw new Error('Required parameter currentValues was null or undefined when calling createUsingPOST.');
        }

        // verify required parameter 'field' is not null or undefined
        if (field === null || field === undefined) {
            throw new Error('Required parameter field was null or undefined when calling createUsingPOST.');
        }

        if (field !== undefined) {
            localVarQueryParameters['field'] = ObjectSerializer.serialize(field, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(currentValues, "Array<CurrentValue>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Array<CurrentValue>; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CurrentValue>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve current values based on a field id.
     * @param id id
     * @param page Results page wanting to be retrieved
     * @param size The number of elements to be returned
     * @param query query
     * @param sort Sorting criteria in the format: object.property(,asc|desc)
     * @param {*} [options] Override http request options.
     */
    public findCurrentValuesByFieldUsingGET(id: string, page: string, size: string, query?: string, sort?: string, options: any = {}): Promise<{ response: ClientResponse; body: CurrentValue; }> {
        const localVarPath = this.basePath + '/api/v1/currentValues/field/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findCurrentValuesByFieldUsingGET.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling findCurrentValuesByFieldUsingGET.');
        }

        // verify required parameter 'size' is not null or undefined
        if (size === null || size === undefined) {
            throw new Error('Required parameter size was null or undefined when calling findCurrentValuesByFieldUsingGET.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (size !== undefined) {
            localVarQueryParameters['size'] = ObjectSerializer.serialize(size, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: CurrentValue; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CurrentValue");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a list of default current values based on a workflow.
     * @param workflow workflow
     * @param {*} [options] Override http request options.
     */
    public findDefaultsByWorkflowUsingGET(workflow: string, options: any = {}): Promise<{ response: ClientResponse; body: Array<CurrentValue>; }> {
        const localVarPath = this.basePath + '/api/v1/currentValues';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling findDefaultsByWorkflowUsingGET.');
        }

        if (workflow !== undefined) {
            localVarQueryParameters['workflow'] = ObjectSerializer.serialize(workflow, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Array<CurrentValue>; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CurrentValue>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve the user value options for a particular user field.
     * @param field field
     * @param page Results page wanting to be retrieved
     * @param query query
     * @param size The number of elements to be returned
     * @param sort Sorting criteria in the format: object.property(,asc|desc)
     * @param {*} [options] Override http request options.
     */
    public findUsersByFieldUsingGET(field: string, page: string, query: string, size: string, sort?: string, options: any = {}): Promise<{ response: ClientResponse; body: PageOfCurrentValue; }> {
        const localVarPath = this.basePath + '/api/v1/currentValues/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'field' is not null or undefined
        if (field === null || field === undefined) {
            throw new Error('Required parameter field was null or undefined when calling findUsersByFieldUsingGET.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling findUsersByFieldUsingGET.');
        }

        // verify required parameter 'query' is not null or undefined
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling findUsersByFieldUsingGET.');
        }

        // verify required parameter 'size' is not null or undefined
        if (size === null || size === undefined) {
            throw new Error('Required parameter size was null or undefined when calling findUsersByFieldUsingGET.');
        }

        if (field !== undefined) {
            localVarQueryParameters['field'] = ObjectSerializer.serialize(field, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (size !== undefined) {
            localVarQueryParameters['size'] = ObjectSerializer.serialize(size, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: PageOfCurrentValue; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageOfCurrentValue");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Clear default status from any existing field default values and update the input current value list to default status. The saved default values are returned after.
     * @param currentValues currentValues
     * @param _default 
     * @param field field
     * @param {*} [options] Override http request options.
     */
    public updateDefaultsUsingPATCH(currentValues: Array<CurrentValue>, _default: 'true', field: string, options: any = {}): Promise<{ response: ClientResponse; body: Array<CurrentValue>; }> {
        const localVarPath = this.basePath + '/api/v1/currentValues';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'currentValues' is not null or undefined
        if (currentValues === null || currentValues === undefined) {
            throw new Error('Required parameter currentValues was null or undefined when calling updateDefaultsUsingPATCH.');
        }

        // verify required parameter '_default' is not null or undefined
        if (_default === null || _default === undefined) {
            throw new Error('Required parameter _default was null or undefined when calling updateDefaultsUsingPATCH.');
        }

        // verify required parameter 'field' is not null or undefined
        if (field === null || field === undefined) {
            throw new Error('Required parameter field was null or undefined when calling updateDefaultsUsingPATCH.');
        }

        if (_default !== undefined) {
            localVarQueryParameters['default'] = ObjectSerializer.serialize(_default, "'true'");
        }

        if (field !== undefined) {
            localVarQueryParameters['field'] = ObjectSerializer.serialize(field, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(currentValues, "Array<CurrentValue>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Array<CurrentValue>; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CurrentValue>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ExternalUsersApiApiKeys {
    Bearer,
}

export class ExternalUsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: ExternalUsersApiApiKeys, value: string) {
        (this.authentications as any)[ExternalUsersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a external user with no attached roles.
     * @param user user
     * @param {*} [options] Override http request options.
     */
    public createUsingPOST1(user: User, options: any = {}): Promise<{ response: ClientResponse; body: User; }> {
        const localVarPath = this.basePath + '/api/v1/users/external';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling createUsingPOST1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(user, "User")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: User; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FieldsApiApiKeys {
    Bearer,
}

export class FieldsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: FieldsApiApiKeys, value: string) {
        (this.authentications as any)[FieldsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a field.
     * @param field field
     * @param {*} [options] Override http request options.
     */
    public createUsingPOST2(field: Field, options: any = {}): Promise<{ response: ClientResponse; body: Field; }> {
        const localVarPath = this.basePath + '/api/v1/fields';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'field' is not null or undefined
        if (field === null || field === undefined) {
            throw new Error('Required parameter field was null or undefined when calling createUsingPOST2.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(field, "Field")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Field; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Field");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a field.
     * @param id id
     * @param {*} [options] Override http request options.
     */
    public deleteUsingDELETE(id: string, options: any = {}): Promise<{ response: ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/fields/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteUsingDELETE.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body?: any; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns whether a field is a field input to a calculation field.
     * @param fieldId fieldId
     * @param {*} [options] Override http request options.
     */
    public fieldIsInputUsingGET(fieldId: string, options: any = {}): Promise<{ response: ClientResponse; body: boolean; }> {
        const localVarPath = this.basePath + '/api/v1/fields/isInput/{fieldId}'
            .replace('{' + 'fieldId' + '}', encodeURIComponent(String(fieldId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fieldId' is not null or undefined
        if (fieldId === null || fieldId === undefined) {
            throw new Error('Required parameter fieldId was null or undefined when calling fieldIsInputUsingGET.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: boolean; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a paginated list of all discrete fields along with their current values.
     * @param page Results page wanting to be retrieved
     * @param size The number of elements to be returned
     * @param archived 
     * @param exclude 
     * @param global 
     * @param id 
     * @param ids 
     * @param nodeId 
     * @param processId 
     * @param query 
     * @param sectionId 
     * @param sort Sorting criteria in the format: object.property(,asc|desc)
     * @param stepId 
     * @param types 
     * @param withInputs 
     * @param withValues 
     * @param workflowId 
     * @param {*} [options] Override http request options.
     */
    public findByDiscreteWithValuesUsingGET(page: string, size: string, archived?: boolean, exclude?: boolean, global?: boolean, id?: string, ids?: Array<string>, nodeId?: string, processId?: string, query?: string, sectionId?: string, sort?: string, stepId?: string, types?: Array<'TEXT' | 'TEXT_AREA' | 'DATE_PICKER' | 'NUMBER' | 'E_SIGNATURE' | 'CHECKBOX' | 'MULTI_SELECT' | 'RADIO' | 'SELECT' | 'USER' | 'ATTACHMENT' | 'CALCULATION' | 'DUE_DATE'>, withInputs?: boolean, withValues?: boolean, workflowId?: string, options: any = {}): Promise<{ response: ClientResponse; body: PageOfField; }> {
        const localVarPath = this.basePath + '/api/v1/fields/discrete/values';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling findByDiscreteWithValuesUsingGET.');
        }

        // verify required parameter 'size' is not null or undefined
        if (size === null || size === undefined) {
            throw new Error('Required parameter size was null or undefined when calling findByDiscreteWithValuesUsingGET.');
        }

        if (archived !== undefined) {
            localVarQueryParameters['archived'] = ObjectSerializer.serialize(archived, "boolean");
        }

        if (exclude !== undefined) {
            localVarQueryParameters['exclude'] = ObjectSerializer.serialize(exclude, "boolean");
        }

        if (global !== undefined) {
            localVarQueryParameters['global'] = ObjectSerializer.serialize(global, "boolean");
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(ids, "Array<string>");
        }

        if (nodeId !== undefined) {
            localVarQueryParameters['nodeId'] = ObjectSerializer.serialize(nodeId, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (processId !== undefined) {
            localVarQueryParameters['processId'] = ObjectSerializer.serialize(processId, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (sectionId !== undefined) {
            localVarQueryParameters['sectionId'] = ObjectSerializer.serialize(sectionId, "string");
        }

        if (size !== undefined) {
            localVarQueryParameters['size'] = ObjectSerializer.serialize(size, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stepId !== undefined) {
            localVarQueryParameters['stepId'] = ObjectSerializer.serialize(stepId, "string");
        }

        if (types !== undefined) {
            localVarQueryParameters['types'] = ObjectSerializer.serialize(types, "Array<'TEXT' | 'TEXT_AREA' | 'DATE_PICKER' | 'NUMBER' | 'E_SIGNATURE' | 'CHECKBOX' | 'MULTI_SELECT' | 'RADIO' | 'SELECT' | 'USER' | 'ATTACHMENT' | 'CALCULATION' | 'DUE_DATE'>");
        }

        if (withInputs !== undefined) {
            localVarQueryParameters['withInputs'] = ObjectSerializer.serialize(withInputs, "boolean");
        }

        if (withValues !== undefined) {
            localVarQueryParameters['withValues'] = ObjectSerializer.serialize(withValues, "boolean");
        }

        if (workflowId !== undefined) {
            localVarQueryParameters['workflowId'] = ObjectSerializer.serialize(workflowId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: PageOfField; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageOfField");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a paginated list of global fields.
     * @param page Results page wanting to be retrieved
     * @param size The number of elements to be returned
     * @param archived 
     * @param exclude 
     * @param global 
     * @param id 
     * @param ids 
     * @param nodeId 
     * @param processId 
     * @param query 
     * @param sectionId 
     * @param sort Sorting criteria in the format: object.property(,asc|desc)
     * @param stepId 
     * @param types 
     * @param withInputs 
     * @param withValues 
     * @param workflowId 
     * @param {*} [options] Override http request options.
     */
    public findByGlobalUsingGET(page: string, size: string, archived?: boolean, exclude?: boolean, global?: boolean, id?: string, ids?: Array<string>, nodeId?: string, processId?: string, query?: string, sectionId?: string, sort?: string, stepId?: string, types?: Array<'TEXT' | 'TEXT_AREA' | 'DATE_PICKER' | 'NUMBER' | 'E_SIGNATURE' | 'CHECKBOX' | 'MULTI_SELECT' | 'RADIO' | 'SELECT' | 'USER' | 'ATTACHMENT' | 'CALCULATION' | 'DUE_DATE'>, withInputs?: boolean, withValues?: boolean, workflowId?: string, options: any = {}): Promise<{ response: ClientResponse; body: PageOfField; }> {
        const localVarPath = this.basePath + '/api/v1/fields/global';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling findByGlobalUsingGET.');
        }

        // verify required parameter 'size' is not null or undefined
        if (size === null || size === undefined) {
            throw new Error('Required parameter size was null or undefined when calling findByGlobalUsingGET.');
        }

        if (archived !== undefined) {
            localVarQueryParameters['archived'] = ObjectSerializer.serialize(archived, "boolean");
        }

        if (exclude !== undefined) {
            localVarQueryParameters['exclude'] = ObjectSerializer.serialize(exclude, "boolean");
        }

        if (global !== undefined) {
            localVarQueryParameters['global'] = ObjectSerializer.serialize(global, "boolean");
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(ids, "Array<string>");
        }

        if (nodeId !== undefined) {
            localVarQueryParameters['nodeId'] = ObjectSerializer.serialize(nodeId, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (processId !== undefined) {
            localVarQueryParameters['processId'] = ObjectSerializer.serialize(processId, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (sectionId !== undefined) {
            localVarQueryParameters['sectionId'] = ObjectSerializer.serialize(sectionId, "string");
        }

        if (size !== undefined) {
            localVarQueryParameters['size'] = ObjectSerializer.serialize(size, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (stepId !== undefined) {
            localVarQueryParameters['stepId'] = ObjectSerializer.serialize(stepId, "string");
        }

        if (types !== undefined) {
            localVarQueryParameters['types'] = ObjectSerializer.serialize(types, "Array<'TEXT' | 'TEXT_AREA' | 'DATE_PICKER' | 'NUMBER' | 'E_SIGNATURE' | 'CHECKBOX' | 'MULTI_SELECT' | 'RADIO' | 'SELECT' | 'USER' | 'ATTACHMENT' | 'CALCULATION' | 'DUE_DATE'>");
        }

        if (withInputs !== undefined) {
            localVarQueryParameters['withInputs'] = ObjectSerializer.serialize(withInputs, "boolean");
        }

        if (withValues !== undefined) {
            localVarQueryParameters['withValues'] = ObjectSerializer.serialize(withValues, "boolean");
        }

        if (workflowId !== undefined) {
            localVarQueryParameters['workflowId'] = ObjectSerializer.serialize(workflowId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: PageOfField; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageOfField");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Find a specific field.
     * @param id id
     * @param archived Retrieve archived values
     * @param {*} [options] Override http request options.
     */
    public findByIdUsingGET(id: string, archived?: boolean, options: any = {}): Promise<{ response: ClientResponse; body: Field; }> {
        const localVarPath = this.basePath + '/api/v1/fields/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findByIdUsingGET.');
        }

        if (archived !== undefined) {
            localVarQueryParameters['archived'] = ObjectSerializer.serialize(archived, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Field; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Field");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a list of fields from a particular a workflow.
     * @param workflowId 
     * @param archived Return archived values.
     * @param exclude 
     * @param global 
     * @param id 
     * @param ids 
     * @param nodeId 
     * @param processId 
     * @param query 
     * @param sectionId 
     * @param stepId 
     * @param types 
     * @param withInputs 
     * @param withValues 
     * @param {*} [options] Override http request options.
     */
    public findByWorkflowUsingGET(workflowId: string, archived?: boolean, exclude?: boolean, global?: boolean, id?: string, ids?: Array<string>, nodeId?: string, processId?: string, query?: string, sectionId?: string, stepId?: string, types?: Array<'TEXT' | 'TEXT_AREA' | 'DATE_PICKER' | 'NUMBER' | 'E_SIGNATURE' | 'CHECKBOX' | 'MULTI_SELECT' | 'RADIO' | 'SELECT' | 'USER' | 'ATTACHMENT' | 'CALCULATION' | 'DUE_DATE'>, withInputs?: boolean, withValues?: boolean, options: any = {}): Promise<{ response: ClientResponse; body: Array<Field>; }> {
        const localVarPath = this.basePath + '/api/v1/fields/workflow/{workflowId}/values'
            .replace('{' + 'workflowId' + '}', encodeURIComponent(String(workflowId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'workflowId' is not null or undefined
        if (workflowId === null || workflowId === undefined) {
            throw new Error('Required parameter workflowId was null or undefined when calling findByWorkflowUsingGET.');
        }

        if (archived !== undefined) {
            localVarQueryParameters['archived'] = ObjectSerializer.serialize(archived, "boolean");
        }

        if (exclude !== undefined) {
            localVarQueryParameters['exclude'] = ObjectSerializer.serialize(exclude, "boolean");
        }

        if (global !== undefined) {
            localVarQueryParameters['global'] = ObjectSerializer.serialize(global, "boolean");
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(ids, "Array<string>");
        }

        if (nodeId !== undefined) {
            localVarQueryParameters['nodeId'] = ObjectSerializer.serialize(nodeId, "string");
        }

        if (processId !== undefined) {
            localVarQueryParameters['processId'] = ObjectSerializer.serialize(processId, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (sectionId !== undefined) {
            localVarQueryParameters['sectionId'] = ObjectSerializer.serialize(sectionId, "string");
        }

        if (stepId !== undefined) {
            localVarQueryParameters['stepId'] = ObjectSerializer.serialize(stepId, "string");
        }

        if (types !== undefined) {
            localVarQueryParameters['types'] = ObjectSerializer.serialize(types, "Array<'TEXT' | 'TEXT_AREA' | 'DATE_PICKER' | 'NUMBER' | 'E_SIGNATURE' | 'CHECKBOX' | 'MULTI_SELECT' | 'RADIO' | 'SELECT' | 'USER' | 'ATTACHMENT' | 'CALCULATION' | 'DUE_DATE'>");
        }

        if (withInputs !== undefined) {
            localVarQueryParameters['withInputs'] = ObjectSerializer.serialize(withInputs, "boolean");
        }

        if (withValues !== undefined) {
            localVarQueryParameters['withValues'] = ObjectSerializer.serialize(withValues, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Array<Field>; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Field>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a paginated list of fields from a particular workflow.
     * @param page 
     * @param workflowId 
     * @param archived 
     * @param exclude 
     * @param global 
     * @param id 
     * @param ids 
     * @param nodeId 
     * @param processId 
     * @param query 
     * @param sectionId 
     * @param stepId 
     * @param types 
     * @param withInputs 
     * @param withValues 
     * @param {*} [options] Override http request options.
     */
    public findByWorkflowUsingGET1(page: string, workflowId: string, archived?: boolean, exclude?: boolean, global?: boolean, id?: string, ids?: Array<string>, nodeId?: string, processId?: string, query?: string, sectionId?: string, stepId?: string, types?: Array<'TEXT' | 'TEXT_AREA' | 'DATE_PICKER' | 'NUMBER' | 'E_SIGNATURE' | 'CHECKBOX' | 'MULTI_SELECT' | 'RADIO' | 'SELECT' | 'USER' | 'ATTACHMENT' | 'CALCULATION' | 'DUE_DATE'>, withInputs?: boolean, withValues?: boolean, options: any = {}): Promise<{ response: ClientResponse; body: PageOfField; }> {
        const localVarPath = this.basePath + '/api/v1/fields/workflow/{workflowId}'
            .replace('{' + 'workflowId' + '}', encodeURIComponent(String(workflowId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling findByWorkflowUsingGET1.');
        }

        // verify required parameter 'workflowId' is not null or undefined
        if (workflowId === null || workflowId === undefined) {
            throw new Error('Required parameter workflowId was null or undefined when calling findByWorkflowUsingGET1.');
        }

        if (archived !== undefined) {
            localVarQueryParameters['archived'] = ObjectSerializer.serialize(archived, "boolean");
        }

        if (exclude !== undefined) {
            localVarQueryParameters['exclude'] = ObjectSerializer.serialize(exclude, "boolean");
        }

        if (global !== undefined) {
            localVarQueryParameters['global'] = ObjectSerializer.serialize(global, "boolean");
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(ids, "Array<string>");
        }

        if (nodeId !== undefined) {
            localVarQueryParameters['nodeId'] = ObjectSerializer.serialize(nodeId, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (processId !== undefined) {
            localVarQueryParameters['processId'] = ObjectSerializer.serialize(processId, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (sectionId !== undefined) {
            localVarQueryParameters['sectionId'] = ObjectSerializer.serialize(sectionId, "string");
        }

        if (stepId !== undefined) {
            localVarQueryParameters['stepId'] = ObjectSerializer.serialize(stepId, "string");
        }

        if (types !== undefined) {
            localVarQueryParameters['types'] = ObjectSerializer.serialize(types, "Array<'TEXT' | 'TEXT_AREA' | 'DATE_PICKER' | 'NUMBER' | 'E_SIGNATURE' | 'CHECKBOX' | 'MULTI_SELECT' | 'RADIO' | 'SELECT' | 'USER' | 'ATTACHMENT' | 'CALCULATION' | 'DUE_DATE'>");
        }

        if (withInputs !== undefined) {
            localVarQueryParameters['withInputs'] = ObjectSerializer.serialize(withInputs, "boolean");
        }

        if (withValues !== undefined) {
            localVarQueryParameters['withValues'] = ObjectSerializer.serialize(withValues, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: PageOfField; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageOfField");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a list of all nested fields.
     * @param archived 
     * @param exclude 
     * @param global 
     * @param id 
     * @param ids 
     * @param nodeId 
     * @param processId 
     * @param query 
     * @param sectionId 
     * @param stepId 
     * @param types 
     * @param withInputs 
     * @param withValues 
     * @param workflowId 
     * @param {*} [options] Override http request options.
     */
    public findInputFieldsByRequestUsingGET(archived?: boolean, exclude?: boolean, global?: boolean, id?: string, ids?: Array<string>, nodeId?: string, processId?: string, query?: string, sectionId?: string, stepId?: string, types?: Array<'TEXT' | 'TEXT_AREA' | 'DATE_PICKER' | 'NUMBER' | 'E_SIGNATURE' | 'CHECKBOX' | 'MULTI_SELECT' | 'RADIO' | 'SELECT' | 'USER' | 'ATTACHMENT' | 'CALCULATION' | 'DUE_DATE'>, withInputs?: boolean, withValues?: boolean, workflowId?: string, options: any = {}): Promise<{ response: ClientResponse; body: Array<Field>; }> {
        const localVarPath = this.basePath + '/api/v1/fields/nested';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (archived !== undefined) {
            localVarQueryParameters['archived'] = ObjectSerializer.serialize(archived, "boolean");
        }

        if (exclude !== undefined) {
            localVarQueryParameters['exclude'] = ObjectSerializer.serialize(exclude, "boolean");
        }

        if (global !== undefined) {
            localVarQueryParameters['global'] = ObjectSerializer.serialize(global, "boolean");
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(ids, "Array<string>");
        }

        if (nodeId !== undefined) {
            localVarQueryParameters['nodeId'] = ObjectSerializer.serialize(nodeId, "string");
        }

        if (processId !== undefined) {
            localVarQueryParameters['processId'] = ObjectSerializer.serialize(processId, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (sectionId !== undefined) {
            localVarQueryParameters['sectionId'] = ObjectSerializer.serialize(sectionId, "string");
        }

        if (stepId !== undefined) {
            localVarQueryParameters['stepId'] = ObjectSerializer.serialize(stepId, "string");
        }

        if (types !== undefined) {
            localVarQueryParameters['types'] = ObjectSerializer.serialize(types, "Array<'TEXT' | 'TEXT_AREA' | 'DATE_PICKER' | 'NUMBER' | 'E_SIGNATURE' | 'CHECKBOX' | 'MULTI_SELECT' | 'RADIO' | 'SELECT' | 'USER' | 'ATTACHMENT' | 'CALCULATION' | 'DUE_DATE'>");
        }

        if (withInputs !== undefined) {
            localVarQueryParameters['withInputs'] = ObjectSerializer.serialize(withInputs, "boolean");
        }

        if (withValues !== undefined) {
            localVarQueryParameters['withValues'] = ObjectSerializer.serialize(withValues, "boolean");
        }

        if (workflowId !== undefined) {
            localVarQueryParameters['workflowId'] = ObjectSerializer.serialize(workflowId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Array<Field>; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Field>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a paginated list of user fields based on a workflow and global user fields.
     * @param workflowId 
     * @param archived 
     * @param exclude 
     * @param global 
     * @param id 
     * @param ids 
     * @param nodeId 
     * @param processId 
     * @param query 
     * @param sectionId 
     * @param stepId 
     * @param types 
     * @param withInputs 
     * @param withValues 
     * @param {*} [options] Override http request options.
     */
    public findUserFieldsByWorkflowOrGlobalUsingGET(workflowId: string, archived?: boolean, exclude?: boolean, global?: boolean, id?: string, ids?: Array<string>, nodeId?: string, processId?: string, query?: string, sectionId?: string, stepId?: string, types?: Array<'TEXT' | 'TEXT_AREA' | 'DATE_PICKER' | 'NUMBER' | 'E_SIGNATURE' | 'CHECKBOX' | 'MULTI_SELECT' | 'RADIO' | 'SELECT' | 'USER' | 'ATTACHMENT' | 'CALCULATION' | 'DUE_DATE'>, withInputs?: boolean, withValues?: boolean, options: any = {}): Promise<{ response: ClientResponse; body: PageOfField; }> {
        const localVarPath = this.basePath + '/api/v1/fields/workflow/{workflowId}/users'
            .replace('{' + 'workflowId' + '}', encodeURIComponent(String(workflowId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'workflowId' is not null or undefined
        if (workflowId === null || workflowId === undefined) {
            throw new Error('Required parameter workflowId was null or undefined when calling findUserFieldsByWorkflowOrGlobalUsingGET.');
        }

        if (archived !== undefined) {
            localVarQueryParameters['archived'] = ObjectSerializer.serialize(archived, "boolean");
        }

        if (exclude !== undefined) {
            localVarQueryParameters['exclude'] = ObjectSerializer.serialize(exclude, "boolean");
        }

        if (global !== undefined) {
            localVarQueryParameters['global'] = ObjectSerializer.serialize(global, "boolean");
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(ids, "Array<string>");
        }

        if (nodeId !== undefined) {
            localVarQueryParameters['nodeId'] = ObjectSerializer.serialize(nodeId, "string");
        }

        if (processId !== undefined) {
            localVarQueryParameters['processId'] = ObjectSerializer.serialize(processId, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (sectionId !== undefined) {
            localVarQueryParameters['sectionId'] = ObjectSerializer.serialize(sectionId, "string");
        }

        if (stepId !== undefined) {
            localVarQueryParameters['stepId'] = ObjectSerializer.serialize(stepId, "string");
        }

        if (types !== undefined) {
            localVarQueryParameters['types'] = ObjectSerializer.serialize(types, "Array<'TEXT' | 'TEXT_AREA' | 'DATE_PICKER' | 'NUMBER' | 'E_SIGNATURE' | 'CHECKBOX' | 'MULTI_SELECT' | 'RADIO' | 'SELECT' | 'USER' | 'ATTACHMENT' | 'CALCULATION' | 'DUE_DATE'>");
        }

        if (withInputs !== undefined) {
            localVarQueryParameters['withInputs'] = ObjectSerializer.serialize(withInputs, "boolean");
        }

        if (withValues !== undefined) {
            localVarQueryParameters['withValues'] = ObjectSerializer.serialize(withValues, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: PageOfField; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageOfField");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a list of all field types.
     * @param {*} [options] Override http request options.
     */
    public listFieldTypesUsingGET(options: any = {}): Promise<{ response: ClientResponse; body: Array<string>; }> {
        const localVarPath = this.basePath + '/api/v1/fields/types';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Array<string>; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RecordsApiApiKeys {
    Bearer,
}

export class RecordsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: RecordsApiApiKeys, value: string) {
        (this.authentications as any)[RecordsApiApiKeys[key]].apiKey = value;
    }
    /**
     * The child may already exist or it may need to be created.
     * @summary Add a child record relationship to the record represented by the path variable.
     * @param child child
     * @param record record
     * @param layout Layout ID
     * @param {*} [options] Override http request options.
     */
    public createChildUsingPOST(child: Record, record: string, layout?: string, options: any = {}): Promise<{ response: ClientResponse; body: FilteredRecord; }> {
        const localVarPath = this.basePath + '/api/v1/assignments/{record}/child'
            .replace('{' + 'record' + '}', encodeURIComponent(String(record)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'child' is not null or undefined
        if (child === null || child === undefined) {
            throw new Error('Required parameter child was null or undefined when calling createChildUsingPOST.');
        }

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error('Required parameter record was null or undefined when calling createChildUsingPOST.');
        }

        if (layout !== undefined) {
            localVarQueryParameters['layout'] = ObjectSerializer.serialize(layout, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(child, "Record")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: FilteredRecord; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FilteredRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The child may already exist or it may need to be created.
     * @summary Add a child record relationship to the record represented by the path variable.
     * @param child child
     * @param record record
     * @param layout Layout ID
     * @param {*} [options] Override http request options.
     */
    public createChildUsingPOST1(child: Record, record: string, layout?: string, options: any = {}): Promise<{ response: ClientResponse; body: FilteredRecord; }> {
        const localVarPath = this.basePath + '/api/v1/records/{record}/child'
            .replace('{' + 'record' + '}', encodeURIComponent(String(record)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'child' is not null or undefined
        if (child === null || child === undefined) {
            throw new Error('Required parameter child was null or undefined when calling createChildUsingPOST1.');
        }

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error('Required parameter record was null or undefined when calling createChildUsingPOST1.');
        }

        if (layout !== undefined) {
            localVarQueryParameters['layout'] = ObjectSerializer.serialize(layout, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(child, "Record")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: FilteredRecord; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FilteredRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The parent may already exist or it may need to be created.
     * @summary Add a parent record relationship to the record represented by the path variable.
     * @param parent parent
     * @param record record
     * @param layout Layout ID
     * @param {*} [options] Override http request options.
     */
    public createParentUsingPOST(parent: Record, record: string, layout?: string, options: any = {}): Promise<{ response: ClientResponse; body: FilteredRecord; }> {
        const localVarPath = this.basePath + '/api/v1/assignments/{record}/parent'
            .replace('{' + 'record' + '}', encodeURIComponent(String(record)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'parent' is not null or undefined
        if (parent === null || parent === undefined) {
            throw new Error('Required parameter parent was null or undefined when calling createParentUsingPOST.');
        }

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error('Required parameter record was null or undefined when calling createParentUsingPOST.');
        }

        if (layout !== undefined) {
            localVarQueryParameters['layout'] = ObjectSerializer.serialize(layout, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parent, "Record")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: FilteredRecord; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FilteredRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The parent may already exist or it may need to be created.
     * @summary Add a parent record relationship to the record represented by the path variable.
     * @param parent parent
     * @param record record
     * @param layout Layout ID
     * @param {*} [options] Override http request options.
     */
    public createParentUsingPOST1(parent: Record, record: string, layout?: string, options: any = {}): Promise<{ response: ClientResponse; body: FilteredRecord; }> {
        const localVarPath = this.basePath + '/api/v1/records/{record}/parent'
            .replace('{' + 'record' + '}', encodeURIComponent(String(record)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'parent' is not null or undefined
        if (parent === null || parent === undefined) {
            throw new Error('Required parameter parent was null or undefined when calling createParentUsingPOST1.');
        }

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error('Required parameter record was null or undefined when calling createParentUsingPOST1.');
        }

        if (layout !== undefined) {
            localVarQueryParameters['layout'] = ObjectSerializer.serialize(layout, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parent, "Record")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: FilteredRecord; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FilteredRecord");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Public assignments must included value map(s). Returns the saved public record.
     * @summary Create a public record.
     * @param record record
     * @param {*} [options] Override http request options.
     */
    public createPublicUsingPOST(record: Record, options: any = {}): Promise<{ response: ClientResponse; body: Record; }> {
        const localVarPath = this.basePath + '/api/v1/assignments/public';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error('Required parameter record was null or undefined when calling createPublicUsingPOST.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(record, "Record")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Record; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Record");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Public assignments must included value map(s). Returns the saved public record.
     * @summary Create a public record.
     * @param record record
     * @param {*} [options] Override http request options.
     */
    public createPublicUsingPOST1(record: Record, options: any = {}): Promise<{ response: ClientResponse; body: Record; }> {
        const localVarPath = this.basePath + '/api/v1/records/public';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error('Required parameter record was null or undefined when calling createPublicUsingPOST1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(record, "Record")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Record; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Record");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The record has a status of IN_PROGRESS. The returned object is the newly created record.
     * @summary Create an record that is assigned to the creator.
     * @param record record
     * @param {*} [options] Override http request options.
     */
    public createRecordUsingPOST(record: Record, options: any = {}): Promise<{ response: ClientResponse; body: Record; }> {
        const localVarPath = this.basePath + '/api/v1/assignments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error('Required parameter record was null or undefined when calling createRecordUsingPOST.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(record, "Record")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Record; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Record");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The record has a status of IN_PROGRESS. The returned object is the newly created record.
     * @summary Create an record that is assigned to the creator.
     * @param record record
     * @param {*} [options] Override http request options.
     */
    public createRecordUsingPOST1(record: Record, options: any = {}): Promise<{ response: ClientResponse; body: Record; }> {
        const localVarPath = this.basePath + '/api/v1/records';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error('Required parameter record was null or undefined when calling createRecordUsingPOST1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(record, "Record")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Record; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Record");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete mapping between two assignments.
     * @param record record
     * @param map Assignment ID to delete mapping with
     * @param {*} [options] Override http request options.
     */
    public deleteMappingUsingDELETE(record: string, map?: string, options: any = {}): Promise<{ response: ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/assignments/{record}'
            .replace('{' + 'record' + '}', encodeURIComponent(String(record)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error('Required parameter record was null or undefined when calling deleteMappingUsingDELETE.');
        }

        if (map !== undefined) {
            localVarQueryParameters['map'] = ObjectSerializer.serialize(map, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body?: any; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an record.
     * @param record record
     * @param {*} [options] Override http request options.
     */
    public deleteUsingDELETE2(record: string, options: any = {}): Promise<{ response: ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/records/{record}'
            .replace('{' + 'record' + '}', encodeURIComponent(String(record)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error('Required parameter record was null or undefined when calling deleteUsingDELETE2.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body?: any; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return all assignments that are greater than the minimum updated time.
     * @param minUpdated Minimum updated time value. The value is a unix timestamp.
     * @param {*} [options] Override http request options.
     */
    public getRecordByMinUpdatedUsingGET(minUpdated?: string, options: any = {}): Promise<{ response: ClientResponse; body: Array<Record>; }> {
        const localVarPath = this.basePath + '/api/v1/assignments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (minUpdated !== undefined) {
            localVarQueryParameters['minUpdated'] = ObjectSerializer.serialize(minUpdated, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Array<Record>; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Record>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return children assignments that are greater than the minimum updated time.
     * @param hasChild 
     * @param minUpdated Minimum updated time value. The value is a unix timestamp.
     * @param {*} [options] Override http request options.
     */
    public getRecordChildrenByLastUpdatedUsingGET1(hasChild: 'true', minUpdated?: string, options: any = {}): Promise<{ response: ClientResponse; body: Array<Record>; }> {
        const localVarPath = this.basePath + '/api/v1/records';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'hasChild' is not null or undefined
        if (hasChild === null || hasChild === undefined) {
            throw new Error('Required parameter hasChild was null or undefined when calling getRecordChildrenByLastUpdatedUsingGET1.');
        }

        if (hasChild !== undefined) {
            localVarQueryParameters['hasChild'] = ObjectSerializer.serialize(hasChild, "'true'");
        }

        if (minUpdated !== undefined) {
            localVarQueryParameters['minUpdated'] = ObjectSerializer.serialize(minUpdated, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Array<Record>; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Record>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Assignment active date is updated to current time if the record is assigned to the principal user. This will transition the record's status from not started to in progress.
     * @summary Open and then return the record.
     * @param record record
     * @param {*} [options] Override http request options.
     */
    public getRecordUsingGET(record: string, options: any = {}): Promise<{ response: ClientResponse; body: Record; }> {
        const localVarPath = this.basePath + '/api/v1/assignments/{record}'
            .replace('{' + 'record' + '}', encodeURIComponent(String(record)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error('Required parameter record was null or undefined when calling getRecordUsingGET.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Record; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Record");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Assignment active date is updated to current time if the record is assigned to the principal user. This will transition the record's status from not started to in progress.
     * @summary Open and then return the record.
     * @param record record
     * @param {*} [options] Override http request options.
     */
    public getRecordUsingGET1(record: string, options: any = {}): Promise<{ response: ClientResponse; body: Record; }> {
        const localVarPath = this.basePath + '/api/v1/records/{record}'
            .replace('{' + 'record' + '}', encodeURIComponent(String(record)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error('Required parameter record was null or undefined when calling getRecordUsingGET1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Record; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Record");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the saved record.
     * @summary Updates the record, redirects it to the appropriate node, and optionally assigns it to another user. Redirects don't trigger record validation.
     * @param record record
     * @param record2 record
     * @param redirect redirect
     * @param {*} [options] Override http request options.
     */
    public redirectRecordUsingPUT(record: string, record2: Record, redirect: string, options: any = {}): Promise<{ response: ClientResponse; body: Record; }> {
        const localVarPath = this.basePath + '/api/v1/assignments/{record}/redirect/{redirect}'
            .replace('{' + 'record' + '}', encodeURIComponent(String(record)))
            .replace('{' + 'redirect' + '}', encodeURIComponent(String(redirect)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error('Required parameter record was null or undefined when calling redirectRecordUsingPUT.');
        }

        // verify required parameter 'record2' is not null or undefined
        if (record2 === null || record2 === undefined) {
            throw new Error('Required parameter record2 was null or undefined when calling redirectRecordUsingPUT.');
        }

        // verify required parameter 'redirect' is not null or undefined
        if (redirect === null || redirect === undefined) {
            throw new Error('Required parameter redirect was null or undefined when calling redirectRecordUsingPUT.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(record2, "Record")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Record; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Record");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the saved record.
     * @summary Updates the record, redirects it to the appropriate node, and optionally assigns it to another user. Redirects don't trigger record validation.
     * @param record record
     * @param record2 record
     * @param redirect redirect
     * @param {*} [options] Override http request options.
     */
    public redirectRecordUsingPUT1(record: string, record2: Record, redirect: string, options: any = {}): Promise<{ response: ClientResponse; body: Record; }> {
        const localVarPath = this.basePath + '/api/v1/records/{record}/redirect/{redirect}'
            .replace('{' + 'record' + '}', encodeURIComponent(String(record)))
            .replace('{' + 'redirect' + '}', encodeURIComponent(String(redirect)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error('Required parameter record was null or undefined when calling redirectRecordUsingPUT1.');
        }

        // verify required parameter 'record2' is not null or undefined
        if (record2 === null || record2 === undefined) {
            throw new Error('Required parameter record2 was null or undefined when calling redirectRecordUsingPUT1.');
        }

        // verify required parameter 'redirect' is not null or undefined
        if (redirect === null || redirect === undefined) {
            throw new Error('Required parameter redirect was null or undefined when calling redirectRecordUsingPUT1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(record2, "Record")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Record; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Record");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the saved record.
     * @summary Updates the record, progresses it to the appropriate node, and optionally assigns it to another user.
     * @param record record
     * @param record2 record
     * @param {*} [options] Override http request options.
     */
    public submitRecordUsingPUT(record: string, record2: Record, options: any = {}): Promise<{ response: ClientResponse; body: Record; }> {
        const localVarPath = this.basePath + '/api/v1/assignments/{record}/progress'
            .replace('{' + 'record' + '}', encodeURIComponent(String(record)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error('Required parameter record was null or undefined when calling submitRecordUsingPUT.');
        }

        // verify required parameter 'record2' is not null or undefined
        if (record2 === null || record2 === undefined) {
            throw new Error('Required parameter record2 was null or undefined when calling submitRecordUsingPUT.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(record2, "Record")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Record; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Record");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the saved record.
     * @summary Updates the record, progresses it to the appropriate node, and optionally assigns it to another user.
     * @param record record
     * @param record2 record
     * @param {*} [options] Override http request options.
     */
    public submitRecordUsingPUT1(record: string, record2: Record, options: any = {}): Promise<{ response: ClientResponse; body: Record; }> {
        const localVarPath = this.basePath + '/api/v1/records/{record}/progress'
            .replace('{' + 'record' + '}', encodeURIComponent(String(record)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error('Required parameter record was null or undefined when calling submitRecordUsingPUT1.');
        }

        // verify required parameter 'record2' is not null or undefined
        if (record2 === null || record2 === undefined) {
            throw new Error('Required parameter record2 was null or undefined when calling submitRecordUsingPUT1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(record2, "Record")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Record; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Record");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the updated record.
     * @summary Updates the record, but does not progress it to the next node.
     * @param record record
     * @param record2 record
     * @param {*} [options] Override http request options.
     */
    public updateRecordUsingPUT(record: string, record2: Record, options: any = {}): Promise<{ response: ClientResponse; body: Record; }> {
        const localVarPath = this.basePath + '/api/v1/assignments/{record}'
            .replace('{' + 'record' + '}', encodeURIComponent(String(record)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error('Required parameter record was null or undefined when calling updateRecordUsingPUT.');
        }

        // verify required parameter 'record2' is not null or undefined
        if (record2 === null || record2 === undefined) {
            throw new Error('Required parameter record2 was null or undefined when calling updateRecordUsingPUT.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(record2, "Record")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Record; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Record");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the updated record.
     * @summary Updates the record, but does not progress it to the next node.
     * @param record record
     * @param record2 record
     * @param {*} [options] Override http request options.
     */
    public updateRecordUsingPUT1(record: string, record2: Record, options: any = {}): Promise<{ response: ClientResponse; body: Record; }> {
        const localVarPath = this.basePath + '/api/v1/records/{record}'
            .replace('{' + 'record' + '}', encodeURIComponent(String(record)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error('Required parameter record was null or undefined when calling updateRecordUsingPUT1.');
        }

        // verify required parameter 'record2' is not null or undefined
        if (record2 === null || record2 === undefined) {
            throw new Error('Required parameter record2 was null or undefined when calling updateRecordUsingPUT1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(record2, "Record")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Record; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Record");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RolesApiApiKeys {
    Bearer,
}

export class RolesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: RolesApiApiKeys, value: string) {
        (this.authentications as any)[RolesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a new role.
     * @param role role
     * @param {*} [options] Override http request options.
     */
    public createUsingPOST3(role: Role, options: any = {}): Promise<{ response: ClientResponse; body: Role; }> {
        const localVarPath = this.basePath + '/api/v1/roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'role' is not null or undefined
        if (role === null || role === undefined) {
            throw new Error('Required parameter role was null or undefined when calling createUsingPOST3.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(role, "Role")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Role; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Role");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return all roles that are active and unlocked.
     * @param {*} [options] Override http request options.
     */
    public findAllUsingGET(options: any = {}): Promise<{ response: ClientResponse; body: Array<Role>; }> {
        const localVarPath = this.basePath + '/api/v1/roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Array<Role>; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Role>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a list of roles that are active and associated to the logged in principal user.
     * @param {*} [options] Override http request options.
     */
    public findByUserUsingGET(options: any = {}): Promise<{ response: ClientResponse; body: Array<Role>; }> {
        const localVarPath = this.basePath + '/api/v1/roles/user';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Array<Role>; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Role>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StepsApiApiKeys {
    Bearer,
}

export class StepsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: StepsApiApiKeys, value: string) {
        (this.authentications as any)[StepsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Return a list of all nodes that are active and attached to a workflow.
     * @param {*} [options] Override http request options.
     */
    public findAllUsingGET1(options: any = {}): Promise<{ response: ClientResponse; body: Array<Step>; }> {
        const localVarPath = this.basePath + '/api/v1/nodes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Array<Step>; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Step>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a list of all nodes that are active and attached to a workflow.
     * @param {*} [options] Override http request options.
     */
    public findAllUsingGET2(options: any = {}): Promise<{ response: ClientResponse; body: Array<Step>; }> {
        const localVarPath = this.basePath + '/api/v1/steps';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Array<Step>; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Step>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Find a specific node.
     * @param id id
     * @param {*} [options] Override http request options.
     */
    public findByIdUsingGET1(id: string, options: any = {}): Promise<{ response: ClientResponse; body: Step; }> {
        const localVarPath = this.basePath + '/api/v1/nodes/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findByIdUsingGET1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Step; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Step");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Find a specific node.
     * @param id id
     * @param {*} [options] Override http request options.
     */
    public findByIdUsingGET2(id: string, options: any = {}): Promise<{ response: ClientResponse; body: Step; }> {
        const localVarPath = this.basePath + '/api/v1/steps/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findByIdUsingGET2.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Step; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Step");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
    Bearer,
}

export class UsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        (this.authentications as any)[UsersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a user with no attached roles.
     * @param user user
     * @param {*} [options] Override http request options.
     */
    public createUsingPOST4(user: User, options: any = {}): Promise<{ response: ClientResponse; body: User; }> {
        const localVarPath = this.basePath + '/api/v1/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling createUsingPOST4.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(user, "User")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: User; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Disable a user. User making the request must have admin privileges.
     * @param id id
     * @param {*} [options] Override http request options.
     */
    public disableUserUsingPUT(id: string, options: any = {}): Promise<{ response: ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/users/disable/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling disableUserUsingPUT.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body?: any; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Enable a user to be active. User making the request must have admin privileges.
     * @param id id
     * @param sendEmail sendEmail
     * @param {*} [options] Override http request options.
     */
    public enableUserUsingPUT(id: string, sendEmail?: string, options: any = {}): Promise<{ response: ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/api/v1/users/enable/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling enableUserUsingPUT.');
        }

        if (sendEmail !== undefined) {
            localVarQueryParameters['sendEmail'] = ObjectSerializer.serialize(sendEmail, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body?: any; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Find all users regardless of status.
     * @param {*} [options] Override http request options.
     */
    public findAllUsingGET3(options: any = {}): Promise<{ response: ClientResponse; body: Array<User>; }> {
        const localVarPath = this.basePath + '/api/v1/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Array<User>; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary importUsers
     * @param file file
     * @param {*} [options] Override http request options.
     */
    public importUsersUsingPOST(file: Buffer, options: any = {}): Promise<{ response: ClientResponse; body: ImportRequest; }> {
        const localVarPath = this.basePath + '/api/v1/users/import';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling importUsersUsingPOST.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: ImportRequest; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ImportRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ValueMapsApiApiKeys {
    Bearer,
}

export class ValueMapsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: ValueMapsApiApiKeys, value: string) {
        (this.authentications as any)[ValueMapsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a value map and associate it to a record.
     * @param currentValueMap currentValueMap
     * @param assignment assignment
     * @param record Assignment ID
     * @param {*} [options] Override http request options.
     */
    public createValueMapUsingPOST(currentValueMap: ValueMap, assignment?: string, record?: string, options: any = {}): Promise<{ response: ClientResponse; body: ValueMap; }> {
        const localVarPath = this.basePath + '/api/v1/valueMaps';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'currentValueMap' is not null or undefined
        if (currentValueMap === null || currentValueMap === undefined) {
            throw new Error('Required parameter currentValueMap was null or undefined when calling createValueMapUsingPOST.');
        }

        if (assignment !== undefined) {
            localVarQueryParameters['assignment'] = ObjectSerializer.serialize(assignment, "string");
        }

        if (record !== undefined) {
            localVarQueryParameters['record'] = ObjectSerializer.serialize(record, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(currentValueMap, "ValueMap")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: ValueMap; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ValueMap");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a list of value maps that are greater than the minimum updated time.
     * @param minUpdated Minimum updated time value. The value is a unix timestamp.
     * @param {*} [options] Override http request options.
     */
    public getValueMapsByMinUpdatedUsingGET(minUpdated?: number, options: any = {}): Promise<{ response: ClientResponse; body: Array<ValueMap>; }> {
        const localVarPath = this.basePath + '/api/v1/valueMaps';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (minUpdated !== undefined) {
            localVarQueryParameters['minUpdated'] = ObjectSerializer.serialize(minUpdated, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Array<ValueMap>; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ValueMap>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WorkflowsApiApiKeys {
    Bearer,
}

export class WorkflowsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: WorkflowsApiApiKeys, value: string) {
        (this.authentications as any)[WorkflowsApiApiKeys[key]].apiKey = value;
    }
    /**
     * If the distinct parameter is passed as true, then this list will filter to distinct relative workflows.If the distinct parameter is omitted or passed as false, then relative workflows will be repeated if there are multiple paths to the relative.
     * @summary Identify all paths from a particular workflow to relative workflows. 
     * @param workflow workflow
     * @param distinct distinct
     * @param {*} [options] Override http request options.
     */
    public findAllRelativesUsingGET(workflow: string, distinct?: boolean, options: any = {}): Promise<{ response: ClientResponse; body: Array<WorkflowResult>; }> {
        const localVarPath = this.basePath + '/api/v1/workflows/relatives';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling findAllRelativesUsingGET.');
        }

        if (distinct !== undefined) {
            localVarQueryParameters['distinct'] = ObjectSerializer.serialize(distinct, "boolean");
        }

        if (workflow !== undefined) {
            localVarQueryParameters['workflow'] = ObjectSerializer.serialize(workflow, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Array<WorkflowResult>; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<WorkflowResult>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a list of all workflows that are active throughout all processes.
     * @param {*} [options] Override http request options.
     */
    public findAllUsingGET4(options: any = {}): Promise<{ response: ClientResponse; body: Array<Workflow>; }> {
        const localVarPath = this.basePath + '/api/v1/workflows';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Array<Workflow>; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Workflow>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Find a specific workflow.
     * @param id id
     * @param {*} [options] Override http request options.
     */
    public findByIdUsingGET3(id: string, options: any = {}): Promise<{ response: ClientResponse; body: Workflow; }> {
        const localVarPath = this.basePath + '/api/v1/workflows/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findByIdUsingGET3.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Workflow; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a workflow that contains a specific node.
     * @param nodeId nodeId
     * @param {*} [options] Override http request options.
     */
    public findByNodeUsingGET(nodeId: string, options: any = {}): Promise<{ response: ClientResponse; body: Workflow; }> {
        const localVarPath = this.basePath + '/api/v1/workflows/node/{nodeId}'
            .replace('{' + 'nodeId' + '}', encodeURIComponent(String(nodeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'nodeId' is not null or undefined
        if (nodeId === null || nodeId === undefined) {
            throw new Error('Required parameter nodeId was null or undefined when calling findByNodeUsingGET.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Workflow; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a list of all workflows that are active throughout all processes.
     * @param page Results page wanting to be retrieved
     * @param size The number of elements to be returned
     * @param query query
     * @param sort Sorting criteria in the format: object.property(,asc|desc)
     * @param {*} [options] Override http request options.
     */
    public findByQueryWithProcessUsingGET(page: string, size: string, query?: string, sort?: string, options: any = {}): Promise<{ response: ClientResponse; body: Array<Workflow>; }> {
        const localVarPath = this.basePath + '/api/v1/workflows/process';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling findByQueryWithProcessUsingGET.');
        }

        // verify required parameter 'size' is not null or undefined
        if (size === null || size === undefined) {
            throw new Error('Required parameter size was null or undefined when calling findByQueryWithProcessUsingGET.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (size !== undefined) {
            localVarQueryParameters['size'] = ObjectSerializer.serialize(size, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Array<Workflow>; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Workflow>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a workflow that contains a specific step.
     * @param stepId stepId
     * @param {*} [options] Override http request options.
     */
    public findByStepUsingGET(stepId: string, options: any = {}): Promise<{ response: ClientResponse; body: Workflow; }> {
        const localVarPath = this.basePath + '/api/v1/workflows/step/{stepId}'
            .replace('{' + 'stepId' + '}', encodeURIComponent(String(stepId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'stepId' is not null or undefined
        if (stepId === null || stepId === undefined) {
            throw new Error('Required parameter stepId was null or undefined when calling findByStepUsingGET.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: ClientResponse; body: Workflow; }>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Workflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body } as { response: any, body: any });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
